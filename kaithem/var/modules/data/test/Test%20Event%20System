continual: false
disabled: false
enable: true
once: true
priority: interactive
rate-limit: 0.0
resource-type: event
trigger: 'True'
versions: {}

#End metadata. Format: metadata, setup, action, delimited by --- on it's own line.
---
#This code runs once when the foot loads. It also runs when you save the event during the test compile
#and may run multiple times when kaithem boots due to dependancy resolution
__doc__=''
from src import newevt,messagebus,modules_state
import time,traceback

def theTest():
    with modules_state.modulesLock:
        modules_state.scopes['x'] = {}
        #Create an event that sets y to 0 if it is 1
        x = newevt.Event("y==1","global y\ny=0",locals(),setup="y=0")
        x.module=x.resource="TEST"

        #Register event with polling.
        x.register()
        #Set y to 1
        x.pymodule.y = 1

        time.sleep(0.1)
        #y should immediately be set back to 0 at the next polling cycle
        if x.pymodule.y == 1:
                raise RuntimeError("Edge-Triggered Event did nothing")

        #Unregister event and make sure it really goes away
        x.unregister()
        x.pymodule.y =1
        if not x.pymodule.y == 1:
                raise RuntimeError("Edge-Triggered Event did not go away when unregistered")

        ##Testing one time events
        x.pymodule.y = False
        def f():
            return x.pymodule.y

        def g():
            x.pymodule.y = False

        newevt.when(f,g)
        time.sleep(0.1)
        x.pymodule.y = True
        time.sleep(0.5)
        if x.pymodule.y:
            raise RuntimeError("One time event did not trigger")

        x.pymodule.y = True
        time.sleep(0.5)
        if not x.pymodule.y:
            raise RuntimeError("One time event did not delete itself properly")
        newevt.after(1,g)

        x.pymodule.y = True
        time.sleep(1.2)
        if x.pymodule.y:
            raise RuntimeError("Time delay event did not trigger")

        x.pymodule.y = True
        time.sleep(1.2)
        if not x.pymodule.y:
            raise RuntimeError("Time delay event did not delete itself properly")

        #Same exact thing exept we use the onchange
        x = newevt.Event("!onchange y","global y\ny=5")
        x.module=x.resource="TEST"


        #Register event with polling.
        x.register()
        #Give it a value to change from
        x.pymodule.y = 0
        #Let it notice the old value
        time.sleep(0.10)
        #Set y to 1
        x.pymodule.y = 1

        time.sleep(0.10)
        #y should immediately be set back to 0 at the next polling cycle
        if x.pymodule.y == 1:
                raise RuntimeError("Onchange Event did nothing")

        #Unregister event and make sure it really goes away
        x.unregister()
        x.pymodule.y =1
        if not x.pymodule.y == 1:
                raise RuntimeError("Onchange Event did not go away when unregistered")

        #Now we test the message bus event
        x = newevt.Event("!onmsg /test","global y\ny='test'")
        #There is a weird old feature where message events don't work if not in EventReferences
        #It was an old thing to caths a circular reference bug.
        with newevt._event_list_lock: #Make sure nobody is iterating the eventlist
            #Add new event
            x.register()
            #Update index
            newevt.EventReferences[x.module,x.resource] = x
        time.sleep(0.25)
        #Give it a value to change from
        messagebus.postMessage("/test",'foo')
        #Let it notice the old value

        time.sleep(0.25)
        print(x.action_wrapper_because_we_need_to_keep_a_reference)
        #y should immediately be set back to 0 at the next polling cycle
        if not hasattr(x.pymodule,'y'):
                time.sleep(5)
                if not hasattr(x.pymodule,'y'):
                    raise RuntimeError("Message Event did nothing or took longer than 5s")
                else:
                    raise RuntimeError("Message Event had slow performance, delivery took more than 0.25s")
 

        #Unregister event and make sure it really goes away
        x.unregister()
        x.pymodule.y =1

        messagebus.postMessage('foo',"/test")
        if x.pymodule.y == 'test':
                raise RuntimeError("Message Event did not go away when unregistered")


        print("Sucess in testing event module")
def runtest():
    try:
        theTest()
    except:
        messagebus.postMessage("/system/notifications/errors",    traceback.format_exc(6))

---
#Uncomment this an it might deadlock.
kaithem.misc.do(runtest)
