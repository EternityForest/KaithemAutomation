continual: true
disabled: false
enable: true
once: true
priority: interactive
rate-limit: 0.0
resource-type: event
trigger: 'True'
versions: {}

#End metadata. Format: metadata, setup, action, delimited by --- on it's own line.
---
#This code runs once when the foot loads. It also runs when you save the event during the test compile
#and may run multiple times when kaithem boots due to dependancy resolution
__doc__=''
from src import newevt,messagebus,modules_state
import time,traceback

def theTest():
    modules_state.scopes['x'] = {}
    #Create an event that sets y to 0 if it is 1
    with newevt._event_list_lock:
        x = newevt.Event("y==1","global y\ny=0",locals(),setup="y=0")
        x.module=x.resource="TEST"

        #Register event with polling.
        x.register()
    #Set y to 1
    x.pymodule.y = 1

    time.sleep(2)
    
    with newevt._event_list_lock:
        #Unregister event and make sure it really goes away
        #We unregister before we do the check that might raise an exception
        #because those events are persistant.
        x.unregister()
        
    #y should immediately be set back to 0 at the next polling cycle
    if x.pymodule.y == 1:
            raise RuntimeError("Edge-Triggered Event did nothing")


    x.pymodule.y =1
    if not x.pymodule.y == 1:
            raise RuntimeError("Edge-Triggered Event did not go away when unregistered")

    blah = [False]

    def f():
        print("f poll",time.time())
        return blah[0]

    def g():
        print("g run",time.time())
        blah[0]=False

    newevt.when(f,g)
    print("make when",time.time())
    time.sleep(0.5)
    blah[0]=True
    print("set when true",time.time())

    time.sleep(0.5)
    if blah[0]:
        print("One time event was slow")
        time.sleep(2)
        if blah[0]:
            raise RuntimeError("One time event did not trigger")

    blah[0]=True
    time.sleep(1)
    if not blah[0]:
        raise RuntimeError("One time event did not delete itself properly")

    newevt.after(1,g)
    print("make after",time.time())
    blah[0]=True
    print("set true",time.time())
    time.sleep(1.5)
    if blah[0]:
        raise RuntimeError("Time delay event did not trigger")

    blah[0] = True
    time.sleep(2)
    if not blah[0]:
        raise RuntimeError("Time delay event did not delete itself properly")

    with newevt._event_list_lock:
        #Same exact thing exept we use the onchange
        x = newevt.Event("!onchange y","global y\ny=5")
         #Give it a value to change from
        x.pymodule.y = 0
        
        x.module=x.resource="TEST"
        #Register event with polling.
        x.register()
   
    #Let it notice the old value
    time.sleep(0.5)
    #Set y to 1
    x.pymodule.y = 1

    time.sleep(0.5)
    #y should immediately be set back to 0 at the next polling cycle
    with newevt._event_list_lock:
        #Unregister event and make sure it really goes away
        x.unregister()
    if x.pymodule.y == 1:
            raise RuntimeError("Onchange Event did nothing")

 

    x.pymodule.y =1
    if not x.pymodule.y == 1:
            raise RuntimeError("Onchange Event did not go away when unregistered")


    #There is a weird old feature where message events don't work if not in EventReferences
    #It was an old thing to caths a circular reference bug.
    with newevt._event_list_lock:
        #Now we test the message bus event
        x = newevt.Event("!onmsg /test","global y\ny='test'")
        #Make sure nobody is iterating the eventlist
        #Add new event
        x.register()
        #Update index
        newevt.EventReferences[x.module,x.resource] = x
    time.sleep(0.25)
    #Give it a value to change from
    messagebus.postMessage("/test",'foo')
    #Let it notice the old value

    time.sleep(0.25)
    with newevt._event_list_lock:
        #Unregister event and make sure it really goes away
        x.unregister()
    #y should immediately be set back to 0 at the next polling cycle
    if not hasattr(x.pymodule,'y'):
            time.sleep(5)
            if not hasattr(x.pymodule,'y'):
                raise RuntimeError("Message Event did nothing or took longer than 5s")
            else:
                raise RuntimeError("Message Event had slow performance, delivery took more than 0.25s")


    x.pymodule.y =1

    messagebus.postMessage('foo',"/test")
    if x.pymodule.y == 'test':
            raise RuntimeError("Message Event did not go away when unregistered")


    print("Success in testing event module")
def runtest():
    try:
        theTest()
    except:
        messagebus.postMessage("/system/notifications/errors",    traceback.format_exc(6))

---
#Uncomment this an it might deadlock....
time.sleep(10)
kaithem.misc.do(runtest)
