allow-origins: ['*']
allow-xss: false
auto-reload: false
auto-reload-interval: 5.0
dont-show-in-index: false
mimetype: text/html
no-header: false
no-navheader: true
require-method: [GET, POST]
require-permissions: [lights/lightboard.admin]
resource-type: page
template-engine: mako

#End YAML metadata, page body mako code begins on first line after ---
---
<%!
#Code Here runs once when page is first rendered. Good place for import statements.
__doc__= ""
boardname = "default"

%>
<title>Lightboard</title>
<style>
    .grey {
        color: grey;
        font-size: 70%;
    }

    div.hfader {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
    }

    p.scene {
        border-style: solid;
        border-radius: 5px;
        border-width: 1px;
        border-color: grey;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    p.run {
        background-color: rgba(128, 190, 128, 0.4);
        !important
    }

    div.universe {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    .indicator {
        border-color: black;
        border-radius: 0.2em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        border-style: dashed;
        border-width: 1.5px;
    }
    

</style>
<script>
    function findMatching(l, k, v)
    {
        for (i of l)
        {
            if (l[i][k] == v)
            {
                return (i)
            }
        }
    }

</script>
<script src="${kaithem.web.resource('jquery-3.1.0')}"></script>
<script src="${kaithem.web.resource('vue-2.3.4')}"></script>
<script type="text/javascript" src="/static/widget.js"></script>
<script src="${kaithem.web.resource('keyboardjs-2.3.1')}"></script>


<script>
    function set(o, k, v)
    {

        if (o[k] == undefined)
        {
            Vue.set(o, k, v)
        }
        for (var key in v)
        {
            // If values of same property are not equal,
            // objects are not equivalent
            if (o[k][key] !== v[key])
            {
                Vue.set(o[k], key, v[key])
            }
        }

        // If we made it this far, objects
        // are considered equivalent
        return true;
    }

</script>

<div id="app">
    <a href="download" title="Download your scenes as a file">Save</a>
    <a href="upload" title="Upload a scenes file">Load</a>
    <a href="save" title="Save to the kaithem registry as the default state at boot">Make Current State the Default</a>
    <p style="background-color:rgba(255,255,255,0.3);"><b>Show Windows:</b>    <label>DMX Setup:
        <input type="checkbox" v-model="showDMXSetup">
    </label>

    <label>Fixture Types:
        <input v-on:change="showhidefixtures" type="checkbox" v-model="showFixtureSetup">
    </label>|

    <label>Fixture Assignments:
        <input type="checkbox" v-model="showfixtureassg" v-on:change="getfixtureassg">
    </label>|

    <label>Sound Browser</label>
    <input type="checkbox" v-model="showsoundoptions">
    </label></p>

    <datalist id="serports">
        <option v-for="i of serports" v-bind:value="i"></option>
    </datalist>

    <div v-if="showDMXSetup" class="sectionbox">
        <h3>Universe Setup</h3>
        <p class="help">These settings are saved immediately to the Kaithem registry when you click
            "Update Settings". To save them to disk, go to the system settings page
            and save the server state to disk.</p>
        <button v-on:click="refreshPorts">Refresh Serial Ports</button>
        <button v-on:click="pushSettings">Update Settings</button><br>
        <br>

        <h4>Universe Status</h4>
        <table border="1">
            <tr>
                <th>Universe</th>
                <th>Status</th>
            </tr>
            <tr v-for="(v,i) in universes">
                <td>{{i}}</td>
                <td v-bind:style="{'color':v.ok?'green':'red'}">{{v.status}}</td>
            </tr>
        </table>
        <br>

        <h4>Serial Ports</h4>
        <span v-for="i in serports">{{i}}<br></span>
        <br>

        <h4>Configure Universes</h4>
        <table border=1>
            <tr>
                <th>Universe</th>
                <th>Type</th>
                <th>Interface</th>
                <th>Framerate</th>
                <th>Channels</th>
                <th>Actions</th>
            </tr>
            <tr v-for="(v,i) in configuredUniverses">
                <td>{{i}}</td>
                <td>
                    <input v-model="v.type" title="The type of universe">
                </td>
                <td>
                    <input list="serports" v-model="v.interface" type="The interface device(Usually a serial port)"
                        placeholder="Default">
                </td>
                <td>
                    <input type=number min=0 max=480 step=0.1 v-model="v.framerate" title="The max frame rate">
                </td>
                <td>
                    <input type=number min=0 max=512 v-model="v.channels" title="The number of channels to send">
                </td>
                <td>
                    <button v-on:click="deleteUniverse(i)">Del</button>
                </td>
            </tr>
        </table>
        <input placeholder="New Universe Name" v-model="newuniversename">
        <button v-on:click="configuredUniverses[newuniversename]={type:'enttec',framerate:44,channels:512}">Add</button>

    </div>

    <div v-if="showFixtureSetup" class="sectionbox">
        <h3>Fixture Setup</h3>

        <select v-model="selectedFixtureClass" v-on:change="getfixtureclass(selectedFixtureClass)">
            <option v-for="(v,i) in fixtureClasses" :value="i">{{i}}
            </option>
        </select>
        <button v-on:click="addfixturetype">Add fixture type</button>
        <button v-on:click="delfixturetype">Delete Selected</button>

        <button>Rename</button>

        <h3>Channels in Fixture Type</h3>
        <div v-for="(v,i) in fixtureClasses[selectedFixtureClass]">
            <h4>{{i}}.</h4>
            <label>Name:
                <input v-on:change="pushfixture(selectedFixtureClass)" v-model="fixtureClasses[selectedFixtureClass][i][0]">
            </label>
            <label>Type:
                <select v-on:change="pushfixture(selectedFixtureClass)" v-model="fixtureClasses[selectedFixtureClass][i][1]"
                    v-on:change="chTypeChanged(i)">
                    <option>red</option>
                    <option>green</option>
                    <option>blue</option>
                    <option>uv</option>
                    <option>white</option>
                    <option>intensity</option>
                    <option>custom</option>
                    <option>fine</option>
                </select>
            </label>

            <label v-if="fixtureClasses[selectedFixtureClass][i][1]=='fine'">
                Matching Coarse:
                <input v-on:change="pushfixture(selectedFixtureClass)" title="The corresponding coarse channel for this fine channel"
                    min=0 max=64 type="number" v-model="fixtureClasses[selectedFixtureClass][i][2]">
            </label>

            <div v-if="fixtureClasses[selectedFixtureClass][i][1]=='custom'">
                <p class="Help">
                    The custom channel type allows you to define a different meaning for a channel depending
                    on what range it is in. This is fairly common for controlling
                    gobos and gobo rotation, etc. Ranges are defined my the inclusive
                    min and max channel of that range, plus a name for that option.</p>
                </p>
                <h5>Ranges for channel {{i}}</h5>
                <table border="1">
                    <tr>
                        <th>Min Val</th>
                        <th>Max Val</th>
                        <th>Option Name</th>
                        <th>Actions</th>
                    </tr>
                    <tr v-for="(w,j) in fixtureClasses[selectedFixtureClass][i].slice(2)">
                        <td>
                            <input v-on:change="pushfixture(selectedFixtureClass)" v-model.number="fixtureClasses[selectedFixtureClass][i][j+2][0]"
                                type="number">
                        </td>
                        <td>
                            <input v-on:change="pushfixture(selectedFixtureClass)" v-model.number="fixtureClasses[selectedFixtureClass][i][j+2][1]"
                                type="number">
                        </td>
                        <td>
                            <input v-on:change="pushfixture(selectedFixtureClass)" v-model.number="fixtureClasses[selectedFixtureClass][i][j+2][2]">
                        </td>
                        <td>
                            <button v-on:click="del(fixtureClasses[selectedFixtureClass][i],j+2)">Del</button>
                        </td>
                    </tr>
                </table>
                <button v-on:click="fixtureClasses[selectedFixtureClass][i].push([0,0,'optionName'])">Add Range</button>
            </div>
        </div>
        <button v-on:click="fixtureClasses[selectedFixtureClass].push(['red','red'])">Add Channel</button>

    </div>


    <div v-if="showfixtureassg" class="sectionbox">
        <h3>Fixture Assignments</h3>
        <p class="Help">Here is where you actually assign fixtures to channels after creating the
            desired fixture types. Clicking Update will cause the new assignments
            to take effect immediately. They are stored in the Kaithem registry,
            use the save server state button in Kaithem's settings to make them permanent.
        </p>
        <p class="help">To Create a fixture, simply add a line of the format "name, type,universe,
            startaddr", where name is freely chosen(letters and numbers only), type
            is an existing fixture type, universe is the name of the universe you
            are putting the fixture in, and startaddr is a number.</p>
        <textarea v-model="fixtureassg" rows=12 cols=45>
        </textarea>
        <div v-if="ferrs">
            <h4>Errors:</h4>
            <pre>{{ferrs}}</pre>
        </div><br>

        <button v-on:click="pushfixtureassg">Update</button>
    </div>

    <div v class="sectionbox" style="float:left;overflow: auto; width:20%; height:90%; resize:both;">
        <label>
            <input size=8 title="Enter a cue's shortcut code here to activate it'" placeholder="Shortcut"
                v-model="sc_code" v-on:keydown.enter="shortcut()"></input>
        </label>
        <button v-on:click="shortcut()">Go!</button>

        <h3 title="All currently active scenes and all scenes that were created through the light board ar shown">Scenes</h3>

        <button v-on:click="scenefilter=''">X</button>
        <input v-model="scenefilter" placeholder="Search" list="tracks" />
        <button v-bind:class="{highlight:showAll==false}" v-on:click="showAll=false" title="Show all active scenes">Active</button>
        <button v-bind:class="{highlight:showAll}" v-on:click="showAll=true" title="Show all scenes owned by this board">Board</button>
        <br/>
        <div id="scene" style="overflow: scroll; max-height:450px;">
            <p v-for="i in formatScenes()" v-bind:class="{'scene':1, 'grey':i[1].doingHandoff, run:i[1].active &(!i[1].doingHandoff)}"
                style="border-style:solid; border-width:1px;">
                <button v-bind:class="{specialentry:i[0]==scenename}" v-on:click="selectscene(i[1],i[0])"><b>{{i[1].name}}</b><span v-if="i[1].ext" class="grey"> (external)</span></button>
                <span v-if="i[1].active && cuemeta[i[1].cue]">{{cuemeta[i[1].cue].name}}</span><br>
                <br>
                <button class="gobutton" v-on:click="go(i[0])">Go!</button>
                <button v-on:click="nextcue(i[0])">&gt&gt</button>
                <button class="stopbutton" v-on:click="stop(i[0])">Stop!</button>
                <button class="deletebutton" v-on:click="delscene(i[0])">del</button>
                <input type="range" max=1 step=0.01 min=0 v-on:input="setalpha(i[0],parseFloat($event.target.value));"
                    :value="alphas[i[0]]"><br>
                <cue-countdown :unixtime="unixtime" :scene="i[1]" :cue="cuemeta[i[1].cue]"></cue-countdown>
                <span v-if="cuemeta[i[1].cue]&&(cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext)">Next Cue: {{cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext}}<br></span>
                <small>Priority:<b>{{i[1].priority}}</b></small>
                <small v-if="i[1].blend!=='normal'">Blend:<b>{{i[1].blend}}</b></small>
                <small v-if="cuemeta[i[1].cue]&&(cuemeta[i[1].cue].sound)"><br>Sound:<b>{{cuemeta[i[1].cue].sound.match(/([^\/]+)$/)[1]}}</b></small>

            </p>
        </div>


        <hr>
        <input id="newscenename" placeholder="New scene name">
        <button v-on:click="addScene()">Add</button>
        <button v-on:click="addMonitorScene()">Add Monitor</button>

    </div>


    <div class="sectionbox" v-if="editingScene && cuemeta[editingScene.cue]" style="display:inline-block; width:75%; resize:both;">
        <h3><span v-on:dblclick="promptRename(scenename)" title="Double click to set scene name"><span v-if="editingScene.blend=='monitor'">Monitor</span>            Scene: {{editingScene.name}}</span> <span class="highlight" v-if="editingScene.active&(!editingScene.doingHandoff)">(running)</span>            Current Cue:
            <button v-on:click="selectcue(scenename,cuemeta[editingScene.cue].name)">{{cuemeta[editingScene.cue].name}}</span>
                <meter v-if="editingScene.active && cuemeta[editingScene.cue].length" min=0 max=1
                    v-bind:value="(unixtime-editingScene.enteredCue)/editingScene.cuelen"></meter>
                <button v-on:click="nextcue(scenename)">Next</button>


                <span class="virtual" v-if="editingScene.doingHandoff">(fading out)</span>
        </h3>
        <label v-if="scenecues[scenename]">Cue Select:
            <select v-model="selectedCues[scenename]" v-on:change="getcuedata(scenecues[scenename][$event.target.value])">
                <option v-for="i in formatCues()" v-bind:value="i[1].name">{{i[1].name}} ({{i[1].number}})</small>
                </option>
            </select>
        </label>
        <input v-model="newcuename" placeholder="New cue name">
        <button v-on:click="addcue(scenename,newcuename)">Add Cue</button>
        <button v-on:click="clonecue(scenename,currentcueid,newcuename)">Clone Cue</button>
        <button v-on:click="rmcue(currentcueid)">Delete Selected</button>
        <button v-on:click="jumptocue(currentcueid)">Jump to Selected</button>

        <hr>
        <div v-if="currentcue" >
            <div >
            <label >Number:
                <input type="number" title="Cue number" style="width:6em" v-on:input="setnumber(currentcueid,$event.target.value)"
                    min=0 step=0.1 v-model="currentcue.number">
            </label>
            <label>Code:
                <input title="Shortcut code used to quickly activate a cue" size="8" v-on:input="setshortcut(currentcueid,$event.target.value)"
                    v-model="currentcue.shortcut">
            </label>
            <label >Track:
                <input type="checkbox" v-on:change="settrack(currentcueid,currentcue.track)" v-model="currentcue.track"
                    title="Track values from previous cue? If false, values not present are always transparent">
            </label>
            <label>Fadein:
                <input type="number" v-on:input="setfadein(currentcueid,$event.target.value)" style="width:3em"
                    min=0 v-model="currentcue.fadein">{{scenemeta[scenename].bpm?"beats":"s"}}
            </label>
            <label>Length:
                <input type="number" v-on:input="setlength(currentcueid,$event.target.value)" v-model="cuemeta[currentcueid].length"
                    style="width:4em" min=0></input>{{scenemeta[scenename].bpm?"beats":"s"}}
            </label>
            <label>Randomize:
                <input type="number" v-on:input="setrandomize(currentcueid,$event.target.value)"
                    title="Randomize the cue length +- this amount" v-model="cuemeta[currentcueid].lengthRandomize"
                    style="width:4em" min=0 step=0.25></input>{{scenemeta[scenename].bpm?"beats":"s"}}
            </label>

            </div>

        <label>Next Cue:
                <input list="cues_in_scene" title="Select a cue to activate when this one ends" v-on:input="setnext(currentcueid,$event.target.value)"
                    v-model="cuemeta[currentcueid].next" v-bind:placeholder="currentcue.defaultnext"></input>
            </label>
            <button v-on:click="gotonext(currentcueid)">Edit Next</button>
            <button v-on:click="clonecue(scenename,currentcueid,currentcue.next)">Clone to Next</button>

            <datalist id="cues_in_scene" v-if="scenecues[scenename].length<50">
                <option v-for="i in Object.keys(scenecues[scenename]).sort()" v-bind:value="i"></option>
            </datalist>

            <label>Wait for manual advance:
                <input type="checkbox" size="16" v-on:change="setwait(currentcueid,currentcue.wait)"
                    v-model="currentcue.wait" title="Prevents automatically triggering to the next cue">
            </label><br>
            <label>Sound:
                <input placeholder="No sound file" v-model="currentcue.sound" style="width:32em;"
                v-on:change="setSoundfile(currentcueid,currentcue.sound)">
            </label>
            <label>Device:
                <input title="Using mplayer -ao syntax, set the output device"
                    v-on:input="setSoundOutput(currentcueid,$event.target.value)" v-model="cuemeta[currentcueid].soundOutput"
                    placeholder="default"></input>
            </label>

            <label>Use Length:
                <input type="checkbox" v-on:change="setrellen(currentcueid,currentcue.rellen)"
                    v-model="currentcue.rellen" title="If checked, the length parameter is interpreted as a delay after the sound cue ends.">
            </label><br>
            Script Bindings:</br>
             <textarea rows=3 cols=35 title="Enter script bindings here that can trigger at the start and end of the cue" v-on:input="setscript(currentcueid,$event.target.value)"
                    v-model="cuemeta[currentcueid].script"></textarea>
            <div v-if="showsoundoptions">
                <h3>Sound Cues</h3>

                <div style="max-height:25em; overflow:scroll; background-color:rgba(255,255,255,0.4);">
                    <h4>{{soundfilesdir}}</h4>
                    <ul>
                        <li style="color:blue; text-decoration:underline;" v-on:click="setSoundfileDir('')">&ltTOP&gt</li>
                        <li v-if="soundfilesdir" style="color:blue; text-decoration:underline;" v-on:click="setSoundfileDir(((soundfilesdir.match(/(.*)[\/\\]/)[1]||'').match(/(.*)[\/\\]/)[1]||'')+'/')">..</li>
                        <li style="color:blue; text-decoration:underline;"  v-on:click="setSoundfileDir(soundfilesdir+i)" v-for="i in soundfileslisting[0]">{{i}}</li>

                    </ul>

                    <ul>
                        <li title="Double click to select" v-on:dblclick="setSoundfile(currentcueid,soundfilesdir+i)" v-for="i in soundfileslisting[1]">{{i}}</li>
                    </ul>
                </div>
            </div>
            <hr>

            <span class="help" v-if="editingScene.ext">This is an external scene that is defined somewhere in code. Any changed made here may be overwritten by the code at any time.</span>

            <div float="right" style="overflow: scroll; max-height:30em;">
                <div class="universe" v-for="i in cuevals[currentcueid]">
                    <span title="Double click to toggle released">
                        <b v-if="chnamelookup(i.u,i.ch)==undefined">{{i.u}}:{{i.ch}}</b>
                        <b v-if="chnamelookup(i.u,i.ch)" v-bind:title="'Actual channel:'+i.u+':'+i.ch">{{channelNames[i.u][i.ch][0]}}.{{channelNames[i.u][i.ch][1]}}</b>                    </span>
                    <span v-if="i.v !== null">
                    <input v-bind:disabled="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='fine'" 
                        v-if="(editingScene.blend!=='monitor')"
                        type="range" v-bind:step="(chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='fine')? 0.01:1"
                         :min="getValueRange(chnamelookup(i.u,i.ch),i.v)[0]"
                         :max="getValueRange(chnamelookup(i.u,i.ch),i.v)[1]"
                        v-on:input="setCueVal(currentcueid,i.u,parseInt(i.ch),parseFloat($event.target.value))" v-model="i.v">


                    <meter v-if="editingScene.blend=='monitor'" type="range" max=255 v-bind:value="i.v"></meter>
                    </span>
                    <span v-if="i.v== null" class=grey>Released</span>



                    <span v-if="!(channelNames[i.u]&&channelNames[i.u][i.ch]&&channelNames[i.u][i.ch][2]=='fine')"
                        title="Double click to set exact value" v-on:dblclick="promptExactVal(currentcueid,i.u,parseInt(i.ch))"
                        style="font-size:80%">{{i.v.toPrecision(4)}}</span>
                    <span class=grey title="Double click to set exact value" v-if="channelNames[i.u]&&channelNames[i.u][i.ch]&&channelNames[i.u][i.ch][2]=='fine'"
                        v-on:dblclick="promptExactVal(currentcueid,i.u,parseInt(i.ch))">auto</span>

                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='red'" v-bind:style="{'background-color': 'rgb('+i.v+ ',0,0)' , 'border-color':'red'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='green'" v-bind:style="{'background-color': 'rgb(0,'+i.v+',0)' , 'border-color':'green'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='blue'" v-bind:style="{'background-color': 'rgb(0,0,'+i.v+')'  , 'border-color':'blue'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='uv'" v-bind:style="{'background-color': 'rgb(i.v,0,'+i.v+')'  , 'border-color':'blue'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='custom'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='intensity'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='white'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>

                    <span v-if="chnamelookup(i.u,i.ch)==undefined" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='custom'"><br>
                    <select :value="getValueRange(chnamelookup(i.u,i.ch),i.v)[2]" v-on:change="setCueVal(currentcueid,i.u,parseInt(i.ch),mapvaluerange(i.v, chnamelookup(i.u,i.ch), $event.target.value))"> 
                        <option v-for="i of chnamelookup(i.u,i.ch).slice(3)" :value="i[2]">{{i[2]}}({{i[0]}} to {{i[1]}})</option>
                    </select>
                    </span>
                </div>
            </div>
            <div style="clear:both">
                <input list="universes" id="newcueu" placeholder="Universe">
                <datalist id="universes">
                    <option v-for="(v,i) of universes" v-bind:value="i">({{v.count}} values)</option>
                </datalist>
                <input type="number" id="newcuevnumber" title="Channel Number" style="width:5em"
                    value="1">
                <button v-on:click="addValToCue()">Add Channel to Scene</button>
                <button v-on:click="rmValFromCue()">Remove</button>
                <label v-if="editingScene.blend=='monitor'">Priority:
                    <input type='number' min=0 max=100 style="width:3em" v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                        v-model="editingScene.priority">
                </label>

                <br><br>
                <div v-if="editingScene.blend!=='monitor'" style="border-style:solid; border-radius:5px;border-color:grey;">


                    <label>Default Alpha:
                        <input type="number" style="width:4em" max=1 step=0.01 min=0 v-on:input="setdalpha(scenename,parseFloat($event.target.value))"
                            v-model="editingScene.dalpha"></input>
                    </label>
                    <label>Blend Mode:
                        <select title="This setting controls blending multiple scenes together" v-on:input="setblend(scenename,$event.target.value)"
                            v-model="editingScene.blend">

                            <option title="Alpha blend with scenes below">normal</option>
                            <option title="Highest Takes Priority, only affect lights if the value is higher than the others">HTP</option>
                            <option title="Limit maximum level">inhibit</option>
                            <option v-for="i in ${[i for i in module.blendmodes.keys()]}">{{i}}</option>

                        </select>
                        <label>Priority:
                            <input type='number' min=0 max=100 style="width:3em" v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                                v-model="editingScene.priority">
                        </label><br>


                        <label title="Check this box to make the scene active at startup">Active By Default:
                            <input type="checkbox" v-on:change="setdactive(scenename,$event.target.checked)"
                                v-model="editingScene.defaultActive"></input>
                        </label>

                        <label title="Scenes inherit from previous scenes even if you jump directly to them">Backtrack:
                            <input type="checkbox" v-on:change="setbacktrack(scenename,$event.target.checked)"
                                v-model="editingScene.backtrack"></input>
                        </label>

                        </br>

                        <hr v-if="editingScene.blendParams !== {}" style="border-style:solid;border-width:1px;border-color:grey;">
                        <label v-for="(j,k) in editingScene.blendParams">{{j[0]}}:
                            <input type="number" style="width:5em" step=0.01 v-bind:title="j[2]" v-on:input="setblendparam(scenename,k,parseFloat($event.target.value))"
                                v-model="editingScene.blendArgs[k]"></input>

                        </label>

                </div>
            </div>
        </div>
        <div v-if="scenecues[scenename][selectedCues[scenename]]==undefined || cuemeta[scenecues[scenename][selectedCues[scenename]]]==undefined">
            Cue data not found...
        </div>

    </div>

    <section style="float:left;">
        <h3>Key Bindings</h3>
        <button v-on:click="editMode" v-bind:class="{highlight:keybindmode=='edit'}">Edit Mode</button>
        <button v-on:click="runMode" v-bind:class="{highlight:keybindmode=='run'}">Run Mode</button>
        Show Help:
        <input type="checkbox" v-model="showkeybindhelp">
        <p class=meubar>Current Bank: {{currentBindingBank}}</p>
        <div v-if="showkeybindhelp">
            <p class="help">
                One keybinding per line, as in space+x: go scene<br> Valid commands:
                <br>sc [shortcutcode]
                <br>go [scene]<br> stop [scene]<br>goto [scene] [cue]
                <br>next [scene]<br> toggle [scene].<br><br> To organize bindings
                into banks, <br>put the bank's name in square brackets on a line.<br>                when the page loads, the bank is 'default'.<br> To switch banks,
                use the bank [name] command.
                <br><br> Use the goto command to make a scene jump to a cue. Example
                "a: goto scenename cuename". You can use either the cue number or
                the cue name in a binding.</br><br> Use sc to trigger all cues attached
                to a given shortcut code. Example: "a: sc code"</br>
                Use go to activate a scene, stop to stop it, and toggle to toggle it.

            </p>
        </div>
        <p>
            <textarea rows=30 cols=80 v-model="keybindscript" v-on:focus="editMode"></textarea>
        </p>
        <button v-on:click="localStorage.setItem('keybind-script',keybindscript)">Save these keybindings to my browser as the defaults</button>


    </section>


</div>


<template id="cue-cd">
    <span>
    <meter v-bind:high=" (cue.length>30)?scene.cuelen-10:scene.cuelen" v-if="scene.active && cue && cue.length" min=0 v-bind:max="scene.cuelen"
    v-bind:value="unixtime-scene.enteredCue"></meter><br>
    <span v-if="scene.active && cue && cue.length">
     Next cue in: {{formatInterval(scene.cuelen-(unixtime-scene.enteredCue))}}
     <br>
     </span></span>
</template>
<div>

    ${module.board.link.render('api_link')}

    <script>
        formatInterval = function(seconds)
        {
            var hours = Math.floor(seconds / 3600);
            var minutes = Math.floor((seconds - (hours * 3600)) /
                60);
            var seconds = seconds - (hours * 3600) - (minutes * 60);
            var tenths = Math.floor((seconds - Math.floor(seconds)) *
                10);
            seconds = Math.floor(seconds);

            var time = "";

            time = hours + "h " + minutes + "m " + seconds + "." +
                tenths + "s"
            return time;
        }
        Vue.component('cue-countdown',
        {
            template: '#cue-cd',
            props: ['unixtime', 'cue', 'scene'],
            data: function()
            {
                return ({ 'formatInterval': formatInterval })
            }
        });

        //# sourceURL=appcode.js 
        appData = {
            //https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss
            'formatInterval': formatInterval,
            'console': console,
            'sc_code': "",
            'unixtime': 0,
            'serports': [],
            'fixtureassg': '',
            //Fixture error info str
            'ferrs': '',
            'showkeybindhelp': false,
            'showfixtureassg': false,
            'fixtureassg': '',
            'showsoundoptions': false,
            'del': Vue.delete,
            'refreshPorts': function()
            {
                api_link.send(['getserports'])
            },
            'pushSettings': function()
            {
                api_link.send(['setconfuniverses', appData.configuredUniverses])
            },

            'showDMXSetup': false,
            'configuredUniverses':
            {
                'blah': { 'type': 'enttec', 'interface': 'xyz' }
            },
            'newuniversename': "",
            'fixtureClasses': { 'dfjlkdjf': [] },
            'selectedFixtureClass': '',
            'showFixtureSetup': false,
            //The selected dir and [[folders][files]] in that dir, for the
            //sound file browser
            'soundfilesdir': '',
            'soundfileslisting': [
                [],
                []
            ],
            'setSoundfileDir': function(i)
            {

                appData.soundfilesdir = i;
                appData.soundfileslisting = [
                    [],
                    []
                ]
                api_link.send(['listsoundfolder', i])
            },
            'setSoundOutput': function(cueid, i)
            {

                api_link.send(['setcuesoundoutput', cueid, i])
            },
            'setSoundfile': function(cueid, i)
            {

                api_link.send(['setcuesound', cueid, i])
            },
            'chTypeChanged': function(i)
            {
                if (appData.fixtureClasses[appData.selectedFixtureClass]
                    [i][1] == 'fine')
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 2, i - 1)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 3, undefined)
                }
                else
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 2, undefined)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 3, undefined)

                }
                appData.pushfixture(i)
            },
            'getValueRange': function(d, v)
            {
                //Given a channel info list structure thing and a value, return the [min,max,name] of the range
                //that the value is in
                if (d == undefined) { return ([0, 255, "Unknown"]) }
                var c = 0
                for (i of d)
                {
                    if (c > 2)
                    {
                        if (i[1] >= v)
                        {
                            //Better to return Unknown then bad data
                            if (i.length == 3)
                            {
                                return (i)
                            }
                        }
                    }
                    c += 1
                }
                return ([0, 255, "Unknown"])
            },
            //Returns new value mapped into the range when user clicks to change the range of a custom val
            //Given current val, new range info and old range info
            'mapvaluerange': function(oldv, d, newrange)
            {
                for (i of d)
                {
                    if (i[2] == newrange)
                    {
                        var newd = i
                        break;
                    }
                }
                var d = appData.getValueRange(d, oldv)

                try
                {
                    var asfraction = (oldv - d[0]) / ((d[1] - d[0]) +
                        1)
                    return Math.round(asfraction * (newd[1] - newd[
                        0] + 1) + newd[0])
                }
                catch (e)
                {
                    return newd[0]
                }
            },

            'pushfixture': function(i)
            {
                api_link.send(['setfixtureclass', i, appData.fixtureClasses[
                    i]])
            },
            'pushfixtureassg': function()
            {
                api_link.send(['setfixtureassg', appData.fixtureassg])
            },
            'getfixtureassg': function()
            {
                api_link.send(['getfixtureassg'])
            },
            'showhidefixtures': function()
            {
                appData.getfixtureclasses()
                appData.selectedFixtureClass = ''
            },
            'getfixtureclasses': function()
            {
                api_link.send(['getfixtureclasses'])
            },
            'getfixtureclass': function(i)
            {
                api_link.send(['getfixtureclass', i])
            },
            'addfixturetype': function()
            {
                x = prompt("New Fixture Type Name:")
                if (x)
                {
                    Vue.set(appData.fixtureClasses, x, [])
                    appData.selectedFixtureType = x
                }
            },
            'delfixturetype': function()
            {
                x = confirm("Really delete?")
                if (x)
                {
                    Vue.delete(appData.fixtureClasses, appData.selectedFixtureType)
                }
                api_link.send(['delfixtureclass', appData.selectedFixtureType])
            },
            'dictView': function(dict, sorts)
            {
                //Given a dict  and a list of sort keys sorts,
                //return a list of [key,value] pairs sorted by the sort 
                //keys. Earlier sort keys take precendence.

                //Keys starting with ! are interpreted as meanng to sort in descending order

                var o = []
                Object.keys(dict).forEach(
                    function(key, index)
                    {
                        o.push([key, dict[key]])
                    })

                var l = []
                for (var i of sorts)
                {
                    //Convert to pairs reverse, string where reverse is -1 if str started with an exclamation point
                    //Get rid of the fist char if so
                    l.push([
                        i[0] == '!' ? -1 : 1,
                        i[0] == "!" ? i.slice(1) : i
                    ])
                }

                o.sort(function(a, b)
                {
                    //For each of the possible soft keys, check if they
                    //are different. If so, compare and possible reverse the ouptut

                    var d = a[1]
                    var d2 = b[1]
                    for (i of l)
                    {
                        var key = i[1]
                        var rev = i[0]
                        if (!(d[key] == d2[key]))
                        {
                            return (d[key] > d2[key] ? 1 :
                                    -1) *
                                rev
                        }

                    }
                    return 0
                });
                return (o)
            },

            'formatScenes': function()
            {
                if (!appData.showAll)
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', '!started', 'name'
                    ]).filter(
                        function(x)
                        {
                            return (x[1].name && x[1].name.includes(
                                appData.scenefilter))
                        }).filter(
                        function(x)
                        {
                            return x[1].active
                        });
                }
                else
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', 'name'
                    ]).filter(function(x)
                    {
                        return ((!x[1].ext) && ((x[1].name &&
                            x[
                                1].name.includes(
                                appData.scenefilter
                            ))))
                    })
                }

            },
            'formatCues': function()
            {
                z = {}
                //list cue objects
                for (i in appData.scenecues[appData.scenename])
                {
                    m = appData.cuemeta[appData.scenecues[appData.scenename]
                        [i]]
                    if (m !== undefined)
                    {
                        z[i] = m
                    }
                }
                return appData.dictView(z, ['number'])
            },
            'promptExactVal': function(cue, u, v)
            {
                var x = prompt("Enter new value for scene")

                if (x != null)
                {
                    if (parseFloat(x))
                    {
                        appData.setCueVal(cue, u, v, Math.max(0,
                            Math.min(
                                parseFloat(x), 255)))
                    }
                }
            },

            'toggleTransparent': function(cue, u, c, v)
            {
                if (v != null)
                {
                    appData.setCueVal(cue, u, c, null)
                }
                else
                {
                    appData.setCueVal(cie, u, c, null)
                }
            },
            'promptRename' (s)
            {
                var x = prompt(
                    "Enter new name for scene(May break existing references to scene)"
                )

                if (x != null)
                {

                    api_link.send(['setscenename', s, x])

                }

            },
            //If false, only show active scenes
            'showAll': true,
            'deleteUniverse': function(u)
            {
                console.log(u)
                Vue.delete(appData.configuredUniverses, u)
            },
            //Filter which scenes are shown in the list
            'scenefilter': '',
            'currentBindingBank': 'default',
            'localStorage': localStorage,
            'keybindscript': localStorage.getItem("keybind-script"),
            'keybindmode': 'edit',
            //Formatted for display
            'cuevals': {},
            //Current per scene alpha channel
            'alphas': {},
            //Used only for autocompletion, it's a list of all known tracks that we've seen so far.
            'knownTracks': {},
            'scenemeta': {},
            'scenename': null,
            'editingScene': null,
            'running_scenes': {},
            'universes': {},
            'allScenes': [],
            'cues': {},
            'newcuename': '',
            'cuemeta': {},

            'selectedCues': {},
            'scenecues': {},
            //Indexed by universe then channel number
            'channelNames': {},
            //same info as scenevals, indexed hierarchally, as [universe][channel]
            //Actual objs are shared too so changing one obj change in in the other.
            'chnamelookup': function(u, c)
            {
                if (appData.channelNames[u] == undefined)
                {
                    return undefined
                }

                return appData.channelNames[u][c]
            },
            'scenedata': {},
            'setCueVal': function(sc, u, ch, val)
            {
                api_link.send(['scv', sc, u, ch, val]);
                appData.cues[sc][u][ch] = val

            },

            'selectcue': function(sc, cue)
            {
                this.selectedCues[sc] = cue
                this.getcuedata(this.scenecues[sc][cue])
            },
            'selectscene': function(sc, sn)
            {
                this.getcuedata(this.scenecues[sn][this.selectedCues[
                    sc] || 'default'])
                this.editingScene = sc;
                this.scenename = sn;
                api_link.send(['gsd', sn]);
            },
            'delscene': function(sc)
            {
                var r = confirm("Really delete scene?");
                if (r == true)
                {
                    api_link.send(['del', sc]);
                }
            },

            'go': function(sc)
            {

                api_link.send(['go', sc]);
            },

            'goByName': function(sn)
            {

                api_link.send(['gobyname', sn]);
            },

            'toggleByName': function(sn)
            {

                api_link.send(['togglebyname', sn]);
            },

            'stopByName': function(sn)
            {

                api_link.send(['stopbyname', sn]);
            },

            'shortcut': function(sc)
            {
                api_link.send(['shortcut', appData.sc_code]);
                appData.sc_code = ''

            },

            'stop': function(sc, sn)
            {
                if (appData.scenemeta[sc].ext)
                {
                    var x = confirm(
                        "Really stop external scene? \nIt will dissapear from the scene listing because it is not owned by this light board.\n You may need to re-save an event to start it again."
                    )
                }
                else
                {
                    var x = true
                }
                if (x)
                {
                    api_link.send(['stop', sc]);
                }
            },
            'setalpha': function(sc, v)
            {
                api_link.send(['setalpha', sc, v]);
                appData.alphas[sc] = v
            },
            'setfade': function(sc, v)
            {

                api_link.send(['setfade', sc, v]);
            },
            'nextcue': function(sc)
            {
                api_link.send(['nextcue', sc]);
            },

            'addcue': function(sc, v)
            {
                api_link.send(['addcue', sc, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)
            },

            'clonecue': function(sc, cue, v)
            {
                api_link.send(['clonecue', cue, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)

            },
            'gotonext': function(currentcueid)
            {
                nextcue = appData.cuemeta[currentcueid].next

                cue = nextcue || (appData.cuemeta[currentcueid].defaultnext)
                if (!cue)
                {
                    return
                }
                api_link.send(['addcue', appData.scenename, nextcue]);
                api_link.send(['getcuedata', cue]);

                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[cue] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    set(appData.scenecues[appData.scenename], cue,
                        undefined);
                }
                setTimeout(function()
                    {
                        Vue.set(appData.selectedCues,
                            appData.scenename, cue)
                    },
                    30)
            },
            'rmcue': function(cue)
            {
                appData.selectedCues[appData.scenename] = 'default'
                api_link.send(['rmcue', cue]);
            },
            'jumptocue': function(cue)
            {
                api_link.send(['jumptocue', cue]);
            },
            'getcuedata': function(c)
            {

                api_link.send(['getcuedata', c]);
            },
            'getcuemeta': function(c)
            {

                api_link.send(['getcuemeta', c]);
            },
            'setnext': function(sc, cue, v)
            {
                api_link.send(['setnext', sc, cue, v]);
            },
            'setscript': function(sc, cue, v)
            {
                api_link.send(['setscript', sc, cue, v]);
            },
            'setshortcut': function(cue, v)
            {
                api_link.send(['setshortcut', cue, v]);
            },
            'setnumber': function(cue, v)
            {
                api_link.send(['setnumber', cue, v]);
            },

            'setfadein': function(cue, v)
            {
                api_link.send(['setfadein', cue, v]);
            },
            'settrack': function(cue, v)
            {
                api_link.send(['settrack', cue, v]);
            },
            'setrellen': function(cue, v)
            {
                api_link.send(['setrellen', cue, v]);
            },
            'setblend': function(sc, v)
            {
                api_link.send(['setblend', sc, v]);
            },
            'setblendparam': function(sc, k, v)
            {

                api_link.send(['setblendarg', sc, k, v]);
            },

            'setdactive': function(sc, v)
            {

                api_link.send(['setdefaultactive', sc, v]);
            },

            'setbacktrack': function(sc, v)
            {

                api_link.send(['setbacktrack', sc, v]);
            },
            'setlength': function(sc, v)
            {

                api_link.send(['setlength', sc, v]);
            },
            'setrandomize': function(sc, v)
            {

                api_link.send(['setrandomize', sc, v]);
            },

            'setdalpha': function(sc, v)
            {

                appData.scenemeta[sc].alpha = v;
                api_link.send(['setdalpha', sc, v]);
            },
            'setpriority': function(sc, v)
            {
                api_link.send(['setpriority', sc, v]);
            },

            'addScene': function()
            {
                api_link.send(['addscene', $('#newscenename').val()]);
            },

            'addMonitorScene': function()
            {
                api_link.send(['addmonitor', $('#newscenename').val()]);
            },
            'addValToCue': function()
            {
                if (!$('#newcueu').val())
                {
                    return
                }
                api_link.send(['addcueval', appData.scenecues[
                        appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    $('#newcueu').val(), parseInt($(
                        '#newcuevnumber').val())
                ]);
                $('#newcuevnumber').val(parseInt($('#newcuevnumber')
                        .val()) +
                    1)

            },
            'rmValFromCue': function()
            {
                api_link.send(['scv', appData.scenecues[appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    $('#newcueu').val(),
                    parseInt($('#newcuevnumber').val()),
                    null
                ])
            },
            'sortscenes': function()
            {

                appData.allScenes.sort(function(a, b)
                {
                    return a[3] - b[3]
                })
            },
            'editMode': function()
            {
                keyboardJS.reset();
                appData.keybindmode = "edit";
            },
            'runMode': function()
            {
                rebind(appData.keybindscript);
                appData.keybindmode = "run";
            },
            //https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
            'isNumeric': function(input)
            {
                var RE = /^-{0,1}\d*\.{0,1}\d+$/;
                return (RE.test(input));
            }

        }


        var sceneslist = new Vue(
        {
            el: '#app',
            data: appData,
            computed:
            {
                "currentcue": function()
                {
                    return (this.cuemeta[this.scenecues[this.scenename]
                        [this.selectedCues[this.scenename]]
                    ])
                },
                "currentcueid": function()
                {
                    return (this.scenecues[this.scenename][this
                        .selectedCues[
                            this.scenename]
                    ])
                }

            }
        })

        function f(v)
        {
            c = v[0]

            if (c == "scenemeta")
            {
                if (appData.cuemeta[v[2].cue] == undefined)
                {
                    appData.getcuemeta(v[2].cue)
                }
                Vue.set(appData.alphas, v[1], v[2].alpha);
                set(appData.scenemeta, v[1], v[2]);
                if (appData.selectedCues[v[1]] == undefined)
                {
                    Vue.set(appData.selectedCues, v[1], 'default')
                }
                //Make an empty list of cues as a placeholder till the real data arrives
                if (appData.scenecues[v[1]] == undefined)
                {
                    Vue.set(appData.scenecues, v[1], {});
                };
            }

            if (c == "cuemeta")
            {
                //Make an empty list of cues if it's not there yet
                if (appData.scenecues[v[2].scene] == undefined)
                {
                    Vue.set(appData.scenecues, v[2].scene, {});
                };
                Vue.set(appData.scenecues[v[2].scene], v[2].name, v[1]);
                set(appData.cuemeta, v[1], v[2]);
            }

            if (c == "serports")
            {
                appData.serports = v[1]
            }
            if (c == 'confuniverses')
            {
                appData.configuredUniverses = v[1]
            }
            if (c == 'universe_status')
            {
                appData.universes[v[1]].status = v[2]
                appData.universes[v[1]].ok = v[3]

            }
            if (c == "delcue")
            {
                c = appData.cuemeta[v[1]]
                Vue.delete(appData.cues, v[1]);
                Vue.delete(appData.cuemeta, v[1]);
                Vue.delete(appData.cuevals, v[1]);
                Vue.delete(appData.scenecues[c.scene], c.name);
            }

            if (c == "cnames")
            {
                Vue.set(appData.channelNames, v[1], v[2])
            }
            if (c == "universes")
            {
                appData.universes = v[1]
            }
            if (c == 'scenecues')
            {
                //Scenecues only gives us cue number and id info.
                //So if the data isn't in cuemeta, fill in what we can
                d = v[2]
                for (i in v[2])
                {
                    if (appData.cuemeta[d[i][0]] == undefined)
                    {
                        Vue.set(appData.cuemeta, d[i][0],
                        {
                            'name': i,
                            'number': d[
                                i][1]
                        })
                    }
                    Vue.set(appData.scenecues[v[1]], i, d[i][0])
                }
            }
            if (c == "cuedata")
            {
                set(appData.cues, v[1], v[2]);
                x = []
                d = {}
                for (i in v[2])
                {
                    if (!(i in appData.channelNames))
                    {
                        api_link.send(['getcnames', i])
                    }
                    d[i] = {}
                    for (j in v[2][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": v[2][i][j]
                        }
                        d[i][j] = y
                        x.push(y)
                    }
                }
                Vue.set(appData.cuevals, v[1], x)
            }
            if (c == "scv")
            {
                if (v[4] == null)
                {
                    Vue.delete(appData.cues[v[1]][v[2]], v[3])
                }
                else
                {
                    if ((appData.cues[v[1]][v[2]] == undefined) && v[4] !==
                        null)
                    {
                        set(appData.cues[v[1]], v[2], {})
                    }
                    set(appData.cues[v[1]][v[2]], v[3], v[4]);

                }

                x = []
                for (i in appData.cues[v[1]])
                {
                    for (j in appData.cues[v[1]][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": appData.cues[v[1]][i][j]
                        }
                        x.push(y)
                    }
                }
                set(appData.cuevals, v[1], x)
            }


            if (c == "go")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', true)

            }
            if (c == "stop")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', false)

            }
            if (c == "ferrs")
            {

                appData.ferrs = v[1]

            }
            if (c == "fixtureclasses")
            {

                appData.fixtureClasses = v[1]
            }
            if (c == "fixtureclass")
            {

                Vue.set(appData.fixtureClasses, v[1], v[2])
            }
            if (c == "fixtureassg")
            {

                appData.fixtureassg = v[1]
            }
            if (c == "del")
            {
                Vue.delete(appData.selectedCues, v[1])
                Vue.delete(appData.scenemeta, v[1])
                Vue.delete(appData.scenedata, v[1])
                Vue.delete(appData.scenevals, v[1])
                Vue.delete(appData.running_scenes, v[1])
                Vue.delete(appData.mtimes, v[1])

            }

            if (c == "newscene")
            {
                appData.allScenes.push([v[1], v[2]])
            }
            if (c == 'soundfolderlisting')
            {
                if (v[1] == appData.soundfilesdir)
                {
                    appData.soundfileslisting = v[2]
                }
            }
        }



        api_link.upd = f
        api_link.send(['gasd']);

    </script>

    <script>
        setInterval(function()
        {
            appData.unixtime = ((new Date()).getTime() /
                1000)
        }, 1000 / 14)
        setInterval(function()
            {
                if ("getGamepads" in navigator)
                {
                    appData.gamepads = navigator.getGamepads();

                }
            },
            1000)
        var shortcut = function(sc)
        {
            return function()
            {
                api_link.send(['shortcut', sc]);

            }
        }
        var next = function(sc)
        {
            return function()
            {
                api_link.send(['nextcuebyname', sc]);

            }
        }
        var goto = function(sc, cue)
        {
            return function()
            {
                api_link.send(['jumpbyname', sc, cue]);

            }
        }
        var goScene = function(sc)
        {
            return function()
            {
                appData.goByName(sc);
            }
        }

        var toggleScene = function(sc)
        {
            return function()
            {
                appData.toggleByName(sc);
            }
        }
        var stopScene = function(sc)
        {
            return function()
            {
                appData.stopByName(sc);
            }
        }
        var switchBank = function(b)
        {
            return function()
            {
                appData.currentBindingBank = b.trim();
                rebind(appData.keybindscript);
            }
        }

        rebind = function(data)
        {
            var banks = data.split("[")
            keyboardJS.reset()
            for (var bank in banks)
            {
                var lines = banks[bank].split('\n')
                //Only happens when a bank switch line is found,
                //so everything before that is available in all banks
                if (lines[0].includes("]"))
                {

                    var firstline = lines[0].replace("]", "").trim()

                    if (firstline != appData.currentBindingBank)
                    {
                        continue;
                    }
                    lines.splice(0, 1);
                }

                for (var i in lines)
                {

                    var line = lines[i].split(":")
                    if (line[1])
                    {
                        try
                        {
                            binding = line[0].trim()
                            command = line[1].trim()
                            command = command.split(" ")
                            if (command[0] == 'go')
                            {
                                keyboardJS.bind(binding, goScene(
                                    command[1]))
                            }
                            if (command[0] == 'sc')
                            {
                                keyboardJS.bind(binding, shortcut(
                                    command[1]))
                            }
                            if (command[0] == 'goto')
                            {
                                keyboardJS.bind(binding, goto(command[1],
                                    command.slice(2).join('').trim()
                                ))
                            }
                            if (command[0] == 'toggle')
                            {
                                keyboardJS.bind(binding, toggleScene(
                                    command[1]))
                            }
                            if (command[0] == 'stop')
                            {
                                keyboardJS.bind(binding, stopScene(
                                    command[
                                        1]))
                            }
                            if (command[0] == 'bank')
                            {
                                //Bank switch on key up, to make sure they run after other stuff
                                keyboardJS.bind(binding, (pass) => 0,
                                    switchBank(command[
                                        1]))
                            }
                            if (command[0] == 'next')
                            {
                                keyboardJS.bind(binding, next(command[
                                    1]))
                            }
                        }
                        catch (e)
                        {
                            alert("Bad binding script line:" + lines[i] +
                                e)
                        }
                    }

                }
            }

        }

    </script>
