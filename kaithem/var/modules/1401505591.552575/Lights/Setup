{
    "action": "n.poll()",
    "continual": false,
    "disabled": false,
    "once": true,
    "priority": "interactive",
    "rate-limit": 0.2,
    "resource-type": "event",
    "setup": "import serial,time,base64,math,struct\r\nclass Node():\r\n    \"Class representing one node that can send and listen for messages\"\r\n    def __init__(self, port,speed):\r\n        \"Given the name of a serial port and baudrate, init the node\"\r\n        self.s = serial.Serial(port,baudrate=speed)\r\n        self.messages = []\r\n        self.lastEmptiedTraffic = time.time()\r\n        self.avgTraffic =0\r\n        self.totalTraffic=0\r\n        def f(x,y):\r\n            self.messages.append((x,y))\r\n\r\n        self.parser = Parser(f)\r\n    \r\n    def setLights(self, start,data):\r\n        d = struct.pack(\"<BHB\",0,start,len(data))\r\n        self.send(b\"STAGE\",d+bytearray(data))\r\n\r\n    def fadeLights(self, start,data,time):\r\n        time = int(time*48)\r\n        d = struct.pack(\"<BHBB\",1,start,len(data),time)\r\n        self.send(b\"STAGE\",d+bytearray(data))\r\n    \r\n     \r\n    def sendTime(self, accuracy):\r\n            x = accuracy/ 255.0\r\n            x = int(math.log(x,2)+0.51)\r\n            y = accuracy/2**x\r\n            self.s.flush()\r\n            #Add half a millisecond to compensate for the average USB response delay\r\n            #Add 50 microseconds to compensate for other delays that probably exist.\r\n            t=time.time() + 0.00055\r\n            self.send(b\"TIME\", struct.pack(\"<qLbB\" , int(t), int((t%1)*(2**32)) , int(x), int(y)  ))\r\n            self.s.flush()\r\n    \r\n    #Send random data on the rand channel.\r\n    def sendRand(self,num=16):\r\n        self.send('RAND',os.urandom(num))\r\n    \r\n    def poll(self):\r\n        \"\"\"\r\n            Process all new bytes that have been recieved since the last time this was called, and return all new messages as\r\n            a list of tuples (channel,message) in order recieved.\r\n        \"\"\"\r\n        \r\n        #calculate the average traffic(note that send also records its traffic)\r\n        self.totalTraffic+= self.s.inWaiting()\r\n        \r\n        timesincelastemptied =time.time()-self.lastEmptiedTraffic\r\n        if timesincelastemptied>1:\r\n            self.avgTraffic = (self.avgTraffic*0.95)+((self.totalTraffic/timesincelastemptied)*0.05)\r\n            self.totalTraffic =0\r\n            self.lastEmptiedTraffic = time.time()\r\n            \r\n            \r\n        x = self.s.read(self.s.inWaiting())\r\n        for i in x:\r\n            self.parser.parseByte(i)\r\n        x = self.messages\r\n        self.messages = []\r\n        return x\r\n\r\n    def send(self,header,message):\r\n        \"\"\"Given a topic and message(binary strings or normal strings), send a message over the bus.\r\n           NOTE: A PC Serial port is NOT fast enough for the CSMA stuff. You may get occasional lost messages with a normal usb to\r\n           serial converter. Use the included leonardo usb to WBTV sketch\"\"\"\r\n           \r\n        #Note that this just spews the data out the port and depends on the\r\n        x = makeMessage(header,message)\r\n        self.totalTraffic += len(x)\r\n        self.s.write(x)\r\n        self.s.flush()\r\n\r\nclass Hash():\r\n    #This class implements the modulo 256 variant of the fletcher checksum\r\n    def __init__(self,sequence = []):\r\n        \"\"\"Create an object representing a has state. The state will be initialized, and if the optional\r\n           Arfumentsequence is provided, it will be hashed.\"\"\"\r\n        self.slow = 0\r\n        self.fast = 0\r\n        self.update(sequence)\r\n\r\n    def update(self,val):\r\n        \"\"\"Update the has state by hashing either 1 integer or a byte array\"\"\"\r\n        if hasattr(val,\"__iter__\"):\r\n            for i in val:\r\n                self.slow +=i\r\n                self.fast += self.slow\r\n        else:\r\n            self.slow += val\r\n            self.fast += self.slow\r\n\r\n    def value(self):\r\n        \"\"\"Return the has state as a byte array\"\"\"\r\n        return bytearray([self.slow%256,self.fast%256])\r\n\r\nclass Parser():\r\n    def __init__(self,callback):\r\n        self.callback = callback #this callback will be called when a message has been recieved\r\n        self.escape = False      #If the last processed char was an escape\r\n        self.inheader = True     #If we are currently recieving header data\r\n        self.header = bytearray(0)\r\n        self.message = bytearray(0)\r\n    \r\n    def _insbuf(self,byte):\r\n        \"\"\"Based on if we are in the header or the message, but a byte in the appropriate place\"\"\"\r\n        if self.inheader:\r\n            self.header.append( byte)\r\n        else:\r\n            self.message.append(byte)\r\n            \r\n    def parseByte(self,byte):\r\n        if isinstance(byte,int):\r\n            pass\r\n        else:\r\n            byte = ord(byte)\r\n\r\n        #If the last byte was an escaped escape put this byte literally in, unset the flag and return\r\n        if self.escape:\r\n            self.escape = False\r\n            self._insbuf(byte)\r\n            return\r\n\r\n        #This part of the code handles unescaped bytes\r\n        #If the byte was an unescaped escape,set the escape flag and return\r\n        if byte == ord(\"\\\\\"):\r\n            self.escape = True\r\n            return\r\n        #If the byte is an unescaped start of text marker, set the flag that says we are in the message not the header.\r\n        if byte == ord(\"~\"):\r\n            self.inheader = False;\r\n            return;\r\n        #If the byte is a newline, that is the end of a message\r\n        if byte == ord(\"\\n\"):\r\n            h = Hash()\r\n            #Hash the message, divider, and the checksum at the end of the message\r\n            h.update(self.header)\r\n            h.update(ord(\"~\"))\r\n            h.update(bytearray(self.message[:-2]))\r\n\r\n            #Compare our hash with the message checksum\r\n            if self.message[-2:]==h.value():\r\n                #Call the callback and delegate processing our new message to it.\r\n                self.callback(bytearray(self.header), bytearray(self.message[:-2]))\r\n            else:\r\n                #Create a message that tells the callback there was an error, if it is interested.\r\n                self.callback(b'CONV',b\"CSERR\"+self.header)\r\n            return\r\n\r\n        #If the byte is a bang, that starts a new message, discarding anything we might have been processing.\r\n        if byte == ord(\"!\"):\r\n            self.inheader = True\r\n            self.message = bytearray(0)\r\n            self.header = bytearray(0)\r\n            return\r\n\r\n        #If we got this far, the byte was just a byte of data to be put in the header or message depending on the state.\r\n        self._insbuf(byte)\r\n\r\ndef makeMessage(header,message):\r\n    h = Hash()\r\n    header = bytearray(header)\r\n    message = bytearray(message)\r\n\r\n    #every message  starts with a bang    \r\n    data = bytearray(b'!')\r\n    \r\n    #Add all the bytes of the header, and hash them, but prepend escapes as needed.\r\n    for i in header:\r\n        if i in [ord(\"\\n\"),ord(\"~\"),ord(\"\\\\\")]:\r\n            data.append(ord('\\\\'))\r\n            data.append(i)\r\n        else:\r\n            data.append( i)\r\n        h.update(i)\r\n\r\n    #Add the separator between message and data.\r\n    data.append( ord('~'))\r\n    h.update(ord('~'))\r\n    \r\n    #Same as we did for the header\r\n    for i in message:\r\n        if i in [ord(\"!\"),ord(\"~\"),ord(\"\\\\\")]:\r\n            data.append(ord('\\\\'))\r\n            data.append(i)\r\n        else:\r\n            data.append(i)\r\n        h.update(i)\r\n        \r\n    #Now append the two checksum bytes        \r\n    data.append(h.value()[0])\r\n    data.append(h.value()[1])\r\n    #And the newline which marks the end\r\n    data.append(ord('\\n'))\r\n    return data\r\nlights= []\r\n\r\nfor i in range(0,24):\r\n    lights.append(kaithem.widget.Slider(min=0,max=255,step=1))\r\n\r\nmodule.lights = lights\r\n\r\nn = Node('/dev/ttyUSB0',9600)\r\nmodule.meter = kaithem.widget.Meter()\r\n\r\ndef a(i):\r\n    def f(user,data):\r\n       kaithem.message.post('debug',data)\r\n       module.meter.write(int(data))\r\n       n.setLights(i,[int(data)])\r\n    module.lights[i].attach(f)\r\n    \r\nfor i in range(0,24):\r\n    a(i)\r\n   \r\n      ",
    "trigger": "True"
}