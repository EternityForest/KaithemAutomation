allow-origins: ['*']
allow-xss: false
auto-reload: false
auto-reload-interval: 5.0
dont-show-in-index: false
mimetype: text/html
no-header: false
no-navheader: true
require-method: [GET, POST]
require-permissions: []
resource-type: page
template-engine: mako

#End YAML metadata, page body mako code begins on first line after ---
---
<%!
#Code Here runs once when page is first rendered. Good place for import statements.
__doc__= ""
boardname = "default"

%>
<title>Lightboard</title>
<style>
    .grey {
        color: grey;
        font-size: 70%;
    }

    div.hfader {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
    }

    div.scene {
        border-style: solid;
        border-radius: 5px;
        border-width: 1px;
        border-color: grey;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    .run {
        background-color: rgba(128, 190, 128, 0.4);
        !important
    }

    div.universe {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    .indicator {
        border-color: black;
        border-radius: 0.2em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        border-style: dashed;
        border-width: 1.5px;
    }

</style>
<script>
    function findMatching(l, k, v)
    {
        for (i of l)
        {
            if (l[i][k] == v)
            {
                return (i)
            }
        }
    }

</script>
<script src="${kaithem.web.resource('jquery-3.1.0')}"></script>
<script src="${kaithem.web.resource('vue-2.3.4')}"></script>
<script type="text/javascript" src="/static/widget.js"></script>
<script src="${kaithem.web.resource('keyboardjs-2.3.1')}"></script>


<script>
    function set(o, k, v)
    {

        if (o[k] == undefined)
        {
            Vue.set(o, k, v)
        }
        for (var key in v)
        {
            // If values of same property are not equal,
            // objects are not equivalent
            if (o[k][key] !== v[key])
            {
                Vue.set(o[k], key, v[key])
            }
        }

        // If we made it this far, objects
        // are considered equivalent
        return true;
    }

</script>

<div id="app">

    <div v class="sectionbox" style="float:left;overflow: auto; width:100%; height:90%; resize:both;" v-if="uimode=='scenes'">
        <label>
            <input size=8 title="Enter a cue's shortcut code here to activate it'" placeholder="Shortcut"
                v-model="sc_code" v-on:keydown.enter="shortcut()"></input>
        </label>
        <button v-on:click="shortcut()">Go!</button><br>
        <button v-on:click="uimode='keybindings'">Keybindings</button>
        <button v-on:click="editMode" v-bind:class="{highlight:keybindmode=='edit'}">Off</button>
        <button v-on:click="runMode" v-bind:class="{highlight:keybindmode=='run'}">On</button><br>
        <h3 title="All currently active scenes and all scenes that were created through the light board ar shown">Scenes</h3>

        <button v-on:click="scenefilter=''">X</button>
        <input v-model="scenefilter" placeholder="Search" list="tracks" />
        <button v-bind:class="{highlight:showAll==false}" v-on:click="showAll=false" title="Show all active scenes">Active</button>
        <button v-bind:class="{highlight:showAll}" v-on:click="showAll=true" title="Show all scenes owned by this board">Board</button>
        <br/>
        <div id="scene" style="overflow: scroll; max-height:450px;">
            <p v-for="i in formatScenes()" v-bind:class="{'scene':1, 'grey':i[1].doingHandoff, 'run':i[1].active &(!i[1].doingHandoff)}"
                style="border-style:solid; border-width:1px;">
                <button v-bind:class="{specialentry:i[0]==scenename}" v-on:click="selectscene(i[1],i[0])" style="font-size:130%"><b>{{i[1].name}}</b><span v-if="i[1].ext" class="grey"> (external)</span></button>
                <span v-if="i[1].active && cuemeta[i[1].cue]">{{cuemeta[i[1].cue].name}}</span><br>
                <br>
                <input type="range" max=1 step=0.01 min=0 v-on:input="setalpha(i[0],parseFloat($event.target.value));"
                    :value="alphas[i[0]]" style="width:85%;height:2em;"><br>
                <button class="gobutton" v-on:click="go(i[0])"  style="width:22%;height:2em;">Go!</button>
                <button v-on:click="nextcue(i[0])"  style="width:20%;height:2em;">&gt&gt</button>
                <button class="stopbutton" v-on:click="stop(i[0])"  style="width:18%;height:2em;">Stop!</button>
    <br>
                <cue-countdown :unixtime="unixtime" :scene="i[1]" :cue="cuemeta[i[1].cue]"></cue-countdown>
                <span v-if="cuemeta[i[1].cue]&&(cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext)">Next Cue: {{cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext}}<br></span>
                <small>Priority:<b>{{i[1].priority}}</b></small>
                <small v-if="i[1].blend!=='normal'">Blend:<b>{{i[1].blend}}</b></small>
                <small v-if="cuemeta[i[1].cue]&&(cuemeta[i[1].cue].sound)"><br>Sound:<b>{{cuemeta[i[1].cue].sound.match(/([^\/]+)$/)[1]}}</b></small>

            </p>
        </div>
    </div>

    <div  class="sectionbox" style="float:left;overflow: auto; width:100%; height:90%; resize:both;" v-if="uimode=='keybindings'">
        <h3>Key Bindings</h3>
       <button v-on:click="uimode='scenes'" width="30%">Back</button>
        <button v-on:click="editMode" v-bind:class="{highlight:keybindmode=='edit'}">Edit</button>
        <button v-on:click="runMode" v-bind:class="{highlight:keybindmode=='run'}">Run</button>
        Show Help:
        <input type="checkbox" v-model="showkeybindhelp">
        <p class=meubar>Current Bank: {{currentBindingBank}}</p>
        <div v-if="showkeybindhelp">
            <p class="help">
                One keybinding per line, as in space+x: go scene<br> Valid commands:
                <br>sc [shortcutcode]
                <br>go [scene]<br> stop [scene]<br>goto [scene] [cue]
                <br>next [scene]<br> toggle [scene].<br><br> To organize bindings
                into banks, <br>put the bank's name in square brackets on a line.<br>                when the page loads, the bank is 'default'.<br> To switch banks,
                use the bank [name] command.
                <br><br> Use the goto command to make a scene jump to a cue. Example
                "a: goto scenename cuename". You can use either the cue number or
                the cue name in a binding.</br><br> Use sc to trigger all cues attached
                to a given shortcut code. Example: "a: sc code"</br>
                Use go to activate a scene, stop to stop it, and toggle to toggle it.

            </p>
        </div>
        <p>
            <textarea style="width:80%;" v-model="keybindscript" v-on:focus="editMode"></textarea>
        </p>
        <button v-on:click="localStorage.setItem('keybind-script',keybindscript)">Save these keybindings to my browser as the defaults.</button>


    </div>

    <div class="sectionbox" style="float:left;overflow: auto; width:100%; height:90%; resize:both;" v-if="uimode=='cues'">
        <button v-on:click="uimode='scenes'" width="90%">Back to scenes listing</button><br>

        <h3>{{editingScene.name}}</h3>
         <div>
            <div v-bind:class="{'scene':1, 'grey':editingScene.doingHandoff, 'run':editingScene.active &(!editingScene.doingHandoff)}"
                style="border-style:solid; border-width:1px;">
                <span v-if="editingScene.ext" class="grey"> (external)</span></button>
                <span v-if="editingScene.active && cuemeta[editingScene.cue]">Current Cue: {{cuemeta[editingScene.cue].name}}</span><br>
                <br>
                  <input type="range" max=1 step=0.01 min=0 v-on:input="setalpha(scenename,parseFloat($event.target.value));"
                    :value="alphas[scenename]"  style="width:85%;height:2em;"><br>
                <button class="gobutton" v-on:click="go(scenename)"  style="width:25%;height:2em;">Go!</button>
                <button v-on:click="nextcue(scenename)"  style="width:15%;height:2em;">&gt&gt</button>
                <button class="stopbutton" v-on:click="stop(scenename)"  style="width:15%;height:2em;">Stop!</button>
              <br>
                <cue-countdown :unixtime="unixtime" :scene="editingScene" :cue="cuemeta[editingScene.cue]"></cue-countdown>
                <span v-if="cuemeta[editingScene.cue]&&(cuemeta[editingScene.cue].next||cuemeta[editingScene.cue].defaultnext)">Next Cue: {{cuemeta[editingScene.cue].next||cuemeta[editingScene.cue].defaultnext}}<br></span>
                <small>Priority:<b>{{editingScene.priority}}</b></small>
                <small v-if="editingScene.blend!=='normal'">Blend:<b>{{editingScene.blend}}</b></small>
                <small v-if="cuemeta[editingScene.cue]&&(cuemeta[editingScene.cue].sound)"><br>Sound:<b>{{cuemeta[editingScene.cue].sound.match(/([^\/]+)$/)[1]}}</b></small>
            </div>
            
            <div v-for="i in formatCues()" v-if="i[1].id" v-bind:style="{'background-color':((cuemeta[editingScene.cue].name==i[1].name)?'lightgreen':'')}">
               <b>{{i[1].name}}</b><br> 
                Number: {{i[1].number}} Shortcut:{{i[1].shortcut}}<br>
                In:{{i[1].fadein}}{{scenemeta[scenename].bpm?"beats":"s"}} Length: {{i[1].length}}{{scenemeta[scenename].bpm?"beats":"s"}}<br>

                Next:{{i[1].nextCue}} Track: {{i[1].track}}<br>
                <td><button v-on:click="jumptocue(i[1].id)" style="width:25%;height:2.5em;">Go</button></td>
            </div>
          
        </div>


    </div>



</div>


<template id="cue-cd">
    <span>
    <meter v-bind:high=" (cue.length>30)?scene.cuelen-10:scene.cuelen" v-if="scene.active && cue && cue.length" min=0 v-bind:max="scene.cuelen"
    v-bind:value="unixtime-scene.enteredCue"></meter><br>
    <span v-if="scene.active && cue && cue.length">
     Next cue in: {{formatInterval(scene.cuelen-(unixtime-scene.enteredCue))}}
     <br>
     </span></span>
</template>
<div>

    ${module.board.link.render('api_link')}

    <script>
        formatInterval = function(seconds)
        {
            var hours = Math.floor(seconds / 3600);
            var minutes = Math.floor((seconds - (hours * 3600)) /
                60);
            var seconds = seconds - (hours * 3600) - (minutes * 60);
            var tenths = Math.floor((seconds - Math.floor(seconds)) *
                10);
            seconds = Math.floor(seconds);

            var time = "";

            time = hours + "h " + minutes + "m " + seconds + "." +
                tenths + "s"
            return time;
        }


        Vue.component('cue-countdown',
        {
            template: '#cue-cd',
            props: ['unixtime', 'cue', 'scene'],
            data: function()
            {
                return ({ 'formatInterval': formatInterval })
            }
        });

        //# sourceURL=appcode.js 
        appData = {
            //https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss
            'formatInterval': formatInterval,
            'console': console,
            'sc_code': "",
            'uimode':"scenes",
            'unixtime': 0,
            'serports': [],
            'fixtureassg': '',
            //Fixture error info str
            'ferrs': '',
            'showkeybindhelp': false,
            'showcuetable':true,
            'showfixtureassg': false,
            'fixtureassg': '',
            'showsoundoptions': false,
            'del': Vue.delete,
            'refreshPorts': function()
            {
                api_link.send(['getserports'])
            },
            'pushSettings': function()
            {
                api_link.send(['setconfuniverses', appData.configuredUniverses])
            },

            'showDMXSetup': false,
            'showsceneoptions': false,
            'configuredUniverses':
            {
                'blah': { 'type': 'enttec', 'interface': 'xyz' }
            },
            'newuniversename': "",
            'fixtureClasses': { 'dfjlkdjf': [] },
            'selectedFixtureClass': '',
            'showFixtureSetup': false,
            //The selected dir and [[folders][files]] in that dir, for the
            //sound file browser
            'soundfilesdir': '',
            'soundfileslisting': [
                [],
                []
            ],
            'setSoundfileDir': function(i)
            {

                appData.soundfilesdir = i;
                appData.soundfileslisting = [
                    [],
                    []
                ]
                api_link.send(['listsoundfolder', i])
            },
            'setSoundOutput': function(cueid, i)
            {

                api_link.send(['setcuesoundoutput', cueid, i])
            },
            'setSoundfile': function(cueid, i)
            {

                api_link.send(['setcuesound', cueid, i])
            },
            'chTypeChanged': function(i)
            {
                if (appData.fixtureClasses[appData.selectedFixtureClass]
                    [i][1] == 'fine')
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 2, i - 1)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 3, undefined)
                }
                else
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 2, undefined)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 3, undefined)

                }
                appData.pushfixture(i)
            },
            'getValueRange': function(d, v)
            {
                //Given a channel info list structure thing and a value, return the [min,max,name] of the range
                //that the value is in
                if (d == undefined) { return ([0, 255, "Unknown"]) }
                var c = 0
                for (i of d)
                {
                    if (c > 2)
                    {
                        if (i[1] >= v)
                        {
                            //Better to return Unknown then bad data
                            if (i.length == 3)
                            {
                                return (i)
                            }
                        }
                    }
                    c += 1
                }
                return ([0, 255, "Unknown"])
            },
            //Returns new value mapped into the range when user clicks to change the range of a custom val
            //Given current val, new range info and old range info
            'mapvaluerange': function(oldv, d, newrange)
            {
                for (i of d)
                {
                    if (i[2] == newrange)
                    {
                        var newd = i
                        break;
                    }
                }
                var d = appData.getValueRange(d, oldv)

                try
                {
                    var asfraction = (oldv - d[0]) / ((d[1] - d[0]) +
                        1)
                    return Math.round(asfraction * (newd[1] - newd[
                        0] + 1) + newd[0])
                }
                catch (e)
                {
                    return newd[0]
                }
            },

            'pushfixture': function(i)
            {
                api_link.send(['setfixtureclass', i, appData.fixtureClasses[
                    i]])
            },
            'pushfixtureassg': function()
            {
                api_link.send(['setfixtureassg', appData.fixtureassg])
            },
            'getfixtureassg': function()
            {
                api_link.send(['getfixtureassg'])
            },
            'showhidefixtures': function()
            {
                appData.getfixtureclasses()
                appData.selectedFixtureClass = ''
            },
            'getfixtureclasses': function()
            {
                api_link.send(['getfixtureclasses'])
            },
            'getfixtureclass': function(i)
            {
                api_link.send(['getfixtureclass', i])
            },
            'addfixturetype': function()
            {
                x = prompt("New Fixture Type Name:")
                if (x)
                {
                    Vue.set(appData.fixtureClasses, x, [])
                    appData.selectedFixtureType = x
                }
            },
            'delfixturetype': function()
            {
                x = confirm("Really delete?")
                if (x)
                {
                    Vue.delete(appData.fixtureClasses, appData.selectedFixtureType)
                }
                api_link.send(['delfixtureclass', appData.selectedFixtureType])
            },
            'dictView': function(dict, sorts)
            {
                //Given a dict  and a list of sort keys sorts,
                //return a list of [key,value] pairs sorted by the sort 
                //keys. Earlier sort keys take precendence.

                //Keys starting with ! are interpreted as meanng to sort in descending order

                var o = []
                Object.keys(dict).forEach(
                    function(key, index)
                    {
                        o.push([key, dict[key]])
                    })

                var l = []
                for (var i of sorts)
                {
                    //Convert to pairs reverse, string where reverse is -1 if str started with an exclamation point
                    //Get rid of the fist char if so
                    l.push([
                        i[0] == '!' ? -1 : 1,
                        i[0] == "!" ? i.slice(1) : i
                    ])
                }

                o.sort(function(a, b)
                {
                    //For each of the possible soft keys, check if they
                    //are different. If so, compare and possible reverse the ouptut

                    var d = a[1]
                    var d2 = b[1]
                    for (i of l)
                    {
                        var key = i[1]
                        var rev = i[0]
                        if (!(d[key] == d2[key]))
                        {
                            return (d[key] > d2[key] ? 1 :
                                    -1) *
                                rev
                        }

                    }
                    return 0
                });
                return (o)
            },

            'formatScenes': function()
            {
                if (!appData.showAll)
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', '!started', 'name'
                    ]).filter(
                        function(x)
                        {
                            return (x[1].name && x[1].name.includes(
                                appData.scenefilter))
                        }).filter(
                        function(x)
                        {
                            return x[1].active
                        });
                }
                else
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', 'name'
                    ]).filter(function(x)
                    {
                        return ((!x[1].ext) && ((x[1].name &&
                            x[
                                1].name.includes(
                                appData.scenefilter
                            ))))
                    })
                }

            },
            'formatCues': function()
            {
                z = {}
                //list cue objects
                for (i in appData.scenecues[appData.scenename])
                {
                    m = appData.cuemeta[appData.scenecues[appData.scenename]
                        [i]]
                    if (m !== undefined)
                    {
                        z[i] = m
                    }
                }
                return appData.dictView(z, ['number'])
            },
            'promptExactVal': function(cue, u, v)
            {
                var x = prompt("Enter new value for scene")

                if (x != null)
                {
                    if (parseFloat(x))
                    {
                        appData.setCueVal(cue, u, v, Math.max(0,
                            Math.min(
                                parseFloat(x), 255)))
                    }
                }
            },

            'toggleTransparent': function(cue, u, c, v)
            {
                if (v != null)
                {
                    appData.setCueVal(cue, u, c, null)
                }
                else
                {
                    appData.setCueVal(cie, u, c, null)
                }
            },
            'promptRename' (s)
            {
                var x = prompt(
                    "Enter new name for scene(May break existing references to scene)"
                )

                if (x != null)
                {

                    api_link.send(['setscenename', s, x])

                }

            },
            //If false, only show active scenes
            'showAll': true,
            'deleteUniverse': function(u)
            {
                console.log(u)
                Vue.delete(appData.configuredUniverses, u)
            },
            //Filter which scenes are shown in the list
            'scenefilter': '',
            'currentBindingBank': 'default',
            'localStorage': localStorage,
            'keybindscript': localStorage.getItem("keybind-script"),
            'keybindmode': 'edit',
            //Formatted for display
            'cuevals': {},
            //Current per scene alpha channel
            'alphas': {},
            //Used only for autocompletion, it's a list of all known tracks that we've seen so far.
            'knownTracks': {},
            'scenemeta': {},
            'scenename': null,
            'editingScene': null,
            'running_scenes': {},
            'universes': {},
            'allScenes': [],
            'cues': {},
            'newcuename': '',
            'cuemeta': {},

            'selectedCues': {},
            'scenecues': {},
            //Indexed by universe then channel number
            'channelNames': {},
            //same info as scenevals, indexed hierarchally, as [universe][channel]
            //Actual objs are shared too so changing one obj change in in the other.
            'chnamelookup': function(u, c)
            {
                if (appData.channelNames[u] == undefined)
                {
                    return undefined
                }

                return appData.channelNames[u][c]
            },
            "getcueid": function(sceneid,cuename)
                            {
                                return (this.scenecues[sceneid][cuename])
                            },
            'scenedata': {},
            'setCueVal': function(sc, u, ch, val)
            {
                api_link.send(['scv', sc, u, ch, val]);
                appData.cues[sc][u][ch] = val

            },

            'selectcue': function(sc, cue)
            {
                this.selectedCues[sc] = cue
                this.getcuedata(this.scenecues[sc][cue])
            },
            'getallcuemeta': function(sn)
            {
             api_link.send(['getallcuemeta', sn]);

            },
            'cond_getcuemeta' : function(b)
            {
                if (b)
                        {
                        api_link.send(['getallcuemeta', this.scenename]);
                        }
            },
            'selectscene': function(sc, sn)
            {
                this.getcuedata(this.scenecues[sn][this.selectedCues[
                    sc] || 'default'])
                this.editingScene = sc;
                this.scenename = sn;
                api_link.send(['gsd', sn]);
                if (this.showcuetable)
                {
                   api_link.send(['getallcuemeta', sn]);
                }
                this.uimode='cues';

            },
            'delscene': function(sc)
            {
                var r = confirm("Really delete scene?");
                if (r == true)
                {
                    api_link.send(['del', sc]);
                }
            },

            'go': function(sc)
            {

                api_link.send(['go', sc]);
            },

            'goByName': function(sn)
            {

                api_link.send(['gobyname', sn]);
            },

            'toggleByName': function(sn)
            {

                api_link.send(['togglebyname', sn]);
            },

            'stopByName': function(sn)
            {

                api_link.send(['stopbyname', sn]);
            },

            'shortcut': function(sc)
            {
                api_link.send(['shortcut', appData.sc_code]);
                appData.sc_code = ''

            },

            'stop': function(sc, sn)
            {
                if (appData.scenemeta[sc].ext)
                {
                    var x = confirm(
                        "Really stop external scene? \nIt will dissapear from the scene listing because it is not owned by this light board.\n You may need to re-save an event to start it again."
                    )
                }
                else
                {
                    var x = true
                }
                if (x)
                {
                    api_link.send(['stop', sc]);
                }
            },

          'setsynckey': function(sc, v)
            {
                api_link.send(['setsynckey', sc, v]);
            },
 

          'setsyncport': function(sc, v)
            {
                api_link.send(['setsyncport', sc, v]);
            },
 
          'setsyncaddr': function(sc, v)
            {
                api_link.send(['setsyncaddr', sc, v]);
            },

        'generateSyncKey' :function(sc,n)
        {
             var x = confirm(
                        "Do you want to assign a new sync key to " +n+"?"
                    )
            if (x)
            {
                api_link.send(['generatesynckey', sc]);

            }
        },
 

            'setalpha': function(sc, v)
            {
                api_link.send(['setalpha', sc, v]);
                appData.alphas[sc] = v
            },


            'setfade': function(sc, v)
            {

                api_link.send(['setfade', sc, v]);
            },
            'nextcue': function(sc)
            {
                api_link.send(['nextcue', sc]);
            },

            'addcue': function(sc, v)
            {
                api_link.send(['addcue', sc, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)
            },

            'clonecue': function(sc, cue, v)
            {
                api_link.send(['clonecue', cue, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)

            },
            'gotonext': function(currentcueid)
            {
                nextcue = appData.cuemeta[currentcueid].next

                cue = nextcue || (appData.cuemeta[currentcueid].defaultnext)
                if (!cue)
                {
                    return
                }
                api_link.send(['addcue', appData.scenename, nextcue]);
                api_link.send(['getcuedata', cue]);

                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[cue] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    set(appData.scenecues[appData.scenename], cue,
                        undefined);
                }
                setTimeout(function()
                    {
                        Vue.set(appData.selectedCues,
                            appData.scenename, cue)
                    },
                    30)
            },
            'rmcue': function(cue)
            {
                appData.selectedCues[appData.scenename] = 'default'
                api_link.send(['rmcue', cue]);
            },
            'jumptocue': function(cue)
            {
                api_link.send(['jumptocue', cue]);
            },
            'getcuedata': function(c)
            {

                api_link.send(['getcuedata', c]);
            },
            'getcuemeta': function(c)
            {

                api_link.send(['getcuemeta', c]);
            },
            'setnext': function(sc, cue, v)
            {
                api_link.send(['setnext', sc, cue, v]);
            },
            'setscript': function(sc, cue, v)
            {
                api_link.send(['setscript', sc, cue, v]);
            },
            'setshortcut': function(cue, v)
            {
                api_link.send(['setshortcut', cue, v]);
            },
            'setnumber': function(cue, v)
            {
                api_link.send(['setnumber', cue, v]);
            },

            'setfadein': function(cue, v)
            {
                api_link.send(['setfadein', cue, v]);
            },
            'settrack': function(cue, v)
            {
                api_link.send(['settrack', cue, v]);
            },
            'setrellen': function(cue, v)
            {
                api_link.send(['setrellen', cue, v]);
            },
            'setblend': function(sc, v)
            {
                api_link.send(['setblend', sc, v]);
            },
            'setblendparam': function(sc, k, v)
            {

                api_link.send(['setblendarg', sc, k, v]);
            },

            'setdactive': function(sc, v)
            {

                api_link.send(['setdefaultactive', sc, v]);
            },

            'setbacktrack': function(sc, v)
            {

                api_link.send(['setbacktrack', sc, v]);
            },
            'setlength': function(sc, v)
            {

                api_link.send(['setlength', sc, v]);
            },
            'setrandomize': function(sc, v)
            {

                api_link.send(['setrandomize', sc, v]);
            },

            'setdalpha': function(sc, v)
            {

                appData.scenemeta[sc].alpha = v;
                api_link.send(['setdalpha', sc, v]);
            },
            'setpriority': function(sc, v)
            {
                api_link.send(['setpriority', sc, v]);
            },

            'addScene': function()
            {
                api_link.send(['addscene', $('#newscenename').val()]);
            },

            'addMonitorScene': function()
            {
                api_link.send(['addmonitor', $('#newscenename').val()]);
            },
            'addValToCue': function()
            {
                if (!$('#newcueu').val())
                {
                    return
                }
                api_link.send(['addcueval', appData.scenecues[
                        appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    $('#newcueu').val(), parseInt($(
                        '#newcuevnumber').val())
                ]);
                $('#newcuevnumber').val(parseInt($('#newcuevnumber')
                        .val()) +
                    1)

            },
            'rmValFromCue': function()
            {
                api_link.send(['scv', appData.scenecues[appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    $('#newcueu').val(),
                    parseInt($('#newcuevnumber').val()),
                    null
                ])
            },
            'sortscenes': function()
            {

                appData.allScenes.sort(function(a, b)
                {
                    return a[3] - b[3]
                })
            },
            'editMode': function()
            {
                appData.keybindmode = "edit";
                keyboardJS.reset();
            },
            'runMode': function()
            {
                rebind(appData.keybindscript);
                appData.keybindmode = "run";
            },
            //https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
            'isNumeric': function(input)
            {
                var RE = /^-{0,1}\d*\.{0,1}\d+$/;
                return (RE.test(input));
            }

        }


        var sceneslist = new Vue(
        {
            el: '#app',
            data: appData,
            computed:
            {
                "currentcue": function()
                {
                    return (this.cuemeta[this.scenecues[this.scenename]
                        [this.selectedCues[this.scenename]]
                    ])
                },
                "currentcueid": function()
                {
                    return (this.scenecues[this.scenename][this
                        .selectedCues[
                            this.scenename]
                    ])
                }

            }
        })

        function f(v)
        {
            c = v[0]

            if (c == "scenemeta")
            {
                if (appData.cuemeta[v[2].cue] == undefined)
                {
                    appData.getcuemeta(v[2].cue)
                }
                Vue.set(appData.alphas, v[1], v[2].alpha);
                set(appData.scenemeta, v[1], v[2]);
                if (appData.selectedCues[v[1]] == undefined)
                {
                    Vue.set(appData.selectedCues, v[1], 'default')
                }
                //Make an empty list of cues as a placeholder till the real data arrives
                if (appData.scenecues[v[1]] == undefined)
                {
                    Vue.set(appData.scenecues, v[1], {});
                };
            }

            if (c == "cuemeta")
            {
                //Make an empty list of cues if it's not there yet
                if (appData.scenecues[v[2].scene] == undefined)
                {
                    Vue.set(appData.scenecues, v[2].scene, {});
                };
                Vue.set(appData.scenecues[v[2].scene], v[2].name, v[1]);
                set(appData.cuemeta, v[1], v[2]);
            }

            if (c == "serports")
            {
                appData.serports = v[1]
            }
            if (c == 'confuniverses')
            {
                appData.configuredUniverses = v[1]
            }
            if (c == 'universe_status')
            {
                appData.universes[v[1]].status = v[2]
                appData.universes[v[1]].ok = v[3]

            }
            if (c == "delcue")
            {
                c = appData.cuemeta[v[1]]
                Vue.delete(appData.cues, v[1]);
                Vue.delete(appData.cuemeta, v[1]);
                Vue.delete(appData.cuevals, v[1]);
                Vue.delete(appData.scenecues[c.scene], c.name);
            }

            if (c == "cnames")
            {
                Vue.set(appData.channelNames, v[1], v[2])
            }
            if (c == "universes")
            {
                appData.universes = v[1]
            }
            if (c == 'scenecues')
            {
                //Scenecues only gives us cue number and id info.
                //So if the data isn't in cuemeta, fill in what we can
                d = v[2]
                for (i in v[2])
                {
                    if (appData.cuemeta[d[i][0]] == undefined)
                    {
                        Vue.set(appData.cuemeta, d[i][0],
                        {
                            'name': i,
                            'number': d[
                                i][1]
                        })
                    }
                    Vue.set(appData.scenecues[v[1]], i, d[i][0])
                }
            }
            if (c == "cuedata")
            {
                set(appData.cues, v[1], v[2]);
                x = []
                d = {}
                for (i in v[2])
                {
                    if (!(i in appData.channelNames))
                    {
                        api_link.send(['getcnames', i])
                    }
                    d[i] = {}
                    for (j in v[2][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": v[2][i][j]
                        }
                        d[i][j] = y
                        x.push(y)
                    }
                }
                Vue.set(appData.cuevals, v[1], x)
            }
            if (c == "scv")
            {
                if (v[4] == null)
                {
                    Vue.delete(appData.cues[v[1]][v[2]], v[3])
                }
                else
                {
                    if ((appData.cues[v[1]][v[2]] == undefined) && v[4] !==
                        null)
                    {
                        set(appData.cues[v[1]], v[2], {})
                    }
                    set(appData.cues[v[1]][v[2]], v[3], v[4]);

                }

                x = []
                for (i in appData.cues[v[1]])
                {
                    for (j in appData.cues[v[1]][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": appData.cues[v[1]][i][j]
                        }
                        x.push(y)
                    }
                }
                set(appData.cuevals, v[1], x)
            }


            if (c == "go")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', true)

            }
            if (c == "stop")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', false)

            }
            if (c == "ferrs")
            {

                appData.ferrs = v[1]

            }
            if (c == "fixtureclasses")
            {

                appData.fixtureClasses = v[1]
            }
            if (c == "fixtureclass")
            {

                Vue.set(appData.fixtureClasses, v[1], v[2])
            }
            if (c == "fixtureassg")
            {

                appData.fixtureassg = v[1]
            }
            if (c == "del")
            {
                Vue.delete(appData.selectedCues, v[1])
                Vue.delete(appData.scenemeta, v[1])
                Vue.delete(appData.scenedata, v[1])
                Vue.delete(appData.scenevals, v[1])
                Vue.delete(appData.running_scenes, v[1])
                Vue.delete(appData.mtimes, v[1])

            }

            if (c == "newscene")
            {
                appData.allScenes.push([v[1], v[2]])
            }
            if (c == 'soundfolderlisting')
            {
                if (v[1] == appData.soundfilesdir)
                {
                    appData.soundfileslisting = v[2]
                }
            }
        }



        api_link.upd = f
        api_link.send(['gasd']);

    </script>

    <script>
        setInterval(function()
        {
            appData.unixtime = api_link.now()/1000
        }, 1000 / 14)
        var shortcut = function(sc)
        {
            return function()
            {
                api_link.send(['shortcut', sc]);

            }
        }
        var next = function(sc)
        {
            return function()
            {
                api_link.send(['nextcuebyname', sc]);

            }
        }
        var goto = function(sc, cue)
        {
            return function()
            {
                api_link.send(['jumpbyname', sc, cue]);

            }
        }
        var goScene = function(sc)
        {
            return function()
            {
                appData.goByName(sc);
            }
        }

        var toggleScene = function(sc)
        {
            return function()
            {
                appData.toggleByName(sc);
            }
        }
        var stopScene = function(sc)
        {
            return function()
            {
                appData.stopByName(sc);
            }
        }
        var switchBank = function(b)
        {
            return function()
            {
                appData.currentBindingBank = b.trim();
                rebind(appData.keybindscript);
            }
        }

        rebind = function(data)
        {
      
            var banks = data.split("[")
            keyboardJS.reset()
            for (var bank in banks)
            {
                var lines = banks[bank].split('\n')
                //Only happens when a bank switch line is found,
                //so everything before that is available in all banks
                if (lines[0].includes("]"))
                {

                    var firstline = lines[0].replace("]", "").trim()

                    if (firstline != appData.currentBindingBank)
                    {
                        continue;
                    }
                    lines.splice(0, 1);
                }

                for (var i in lines)
                {

                    var line = lines[i].split(":")
                    if (line[1])
                    {
                        try
                        {
                            binding = line[0].trim()
                            command = line[1].trim()
                            command = command.split(" ")



                            if (command[0] == 'go')
                            {
                                keyboardJS.bind(binding, goScene(
                                    command[1]))
                            }
                            if (command[0] == 'sc')
                            {
                                keyboardJS.bind(binding, shortcut(
                                    command[1]))
                            }
                            if (command[0] == 'goto')
                            {
                                keyboardJS.bind(binding, goto(command[1],
                                    command.slice(2).join('').trim()
                                ))
                            }
                            if (command[0] == 'toggle')
                            {
                                keyboardJS.bind(binding, toggleScene(
                                    command[1]))
                            }
                            if (command[0] == 'stop')
                            {
                                keyboardJS.bind(binding, stopScene(
                                    command[
                                        1]))
                            }
                            if (command[0] == 'bank')
                            {
                                //Bank switch on key up, to make sure they run after other stuff
                                keyboardJS.bind(binding, (pass) => 0,
                                    switchBank(command[
                                        1]))
                            }
                            if (command[0] == 'next')
                            {
                                keyboardJS.bind(binding, next(command[
                                    1]))
                            }
                            }
                        
                        catch (e)
                        {
                            alert("Bad binding script line:" + lines[i] +
                                e)
                        }
                    }

                }
            }

        }

    </script>
