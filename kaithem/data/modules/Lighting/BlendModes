continual: false
enable: true
once: true
priority: interactive
rate-limit: 0.0
resource-type: event
trigger: 'False'
versions: {}

#End metadata. Format: metadata, setup, action, delimited by --- on it's own line.
---
#This code runs once when the event loads. It also runs when you save the event during the test compile
#and may run multiple times when kaithem boots due to dependancy resolution
__doc__=''
import time,random, math

class flicker_blendmode():
    "Blend mode based on physical model flickering"
    parameters = {"gustiness": ("Gustiness","number","",0.2),
                    "lowpass": ("Lowpass","number","",0.2),
                    "topple_chance": ("Windiness","number","",0.1),
                    "agility": ("Flame agility","number","",0.15),
                 }
    def __init__(self,scene):
        self.scene = scene
        self.setup()
        self.wind = 1

        self.wind_gust_chance = 0.01
        self.topple_chance = 0.1
        self.riserate = 0.04
        self.last = time.time()
    
    def setup(self):
        self.affect = {}
        self.heights = {}
        self.heights_lp = {}
        for i in self.scene.values:
            self.heights[i] = [1]*len(self.scene.values[i])
            self.heights_lp[i] = [1]*len(self.scene.values[i])
            self.affect[i] = sorted(self.scene.values[i].keys())

    def frame(self,u,values):

        #Time in 60ths of a second since last frame, so we can keep a consistant frame rate
        t60 = (time.time()-self.last)*60
        self.last = time.time()

        lp = t60*0.05
        self.wind =1*lp + self.wind*(1-lp)

        if random.random() < self.scene.blendArgs['gustiness']*t60:
            self.wind = max(random.normalvariate(1.3,1),1.2)
        if random.random()< 0.08:
            rr =  self.scene.blendArgs['agility']
            self.riserate = random.normalvariate(rr,rr/(4.0*128))
        #It's always changing so always rerender
        self.scene.rerender = True
        lastv =0
        ctr = 0
        tc =  self.scene.blendArgs['topple_chance']
        lps =  self.scene.blendArgs['lowpass']

        for k,v in enumerate(self.affect[u]):

            #Detect RGB groups of 3, put them all together.
            #Reset group on finding a gap to account for typical DMX layouts
            if not self.scene.values[u][v]:
                continue

            if((not (ctr%3)) or v-lastv>1):
                t = random.random()
                ctr=0
                nv = random.triangular(0,1,0.2)
                #lowpass filtering constant for this set of 3
                lp = t60*random.triangular(0,lps,lps/2.0)
                rise = random.random()*self.riserate*t60

            ctr+=1

            lastv = v
            if t < (tc*self.wind*t60):
                self.heights[u][k] = min(1-(nv*(self.scene.values[u][v]/255.0)), self.heights[u][k]+0.1)
            else:
                if self.heights[u][k]<1:
                    self.heights[u][k] += rise/self.scene.values[u][v]
                else:
                    self.heights[u][k]=1

            self.heights_lp[u][k] = self.heights_lp[u][k]*(1-lp) + self.heights[u][k]*(lp)
            values[v] *= min((self.scene.alpha*self.heights_lp[u][k])+ 1-self.scene.alpha,255)



class vary_blendmode():
    "Ads random variation, basically a random time varying gel"
    parameters = {"interval": ("Change Interval","number","How many seconds between changes",1.2),
                    "rinterval": ("Randomize Interval","number","Amount to randmoly vary change interval",0.5),
                    "speed": ("Speed","number","How fast to change",0.015),
                 }
    def __init__(self,scene):
        
        self.wind = 1
        self.vals = {}
        self.vals_lp = {}
        self.scene = scene
        self.affect = {}
        self.ntt = 0
        for i in self.scene.values:
            self.vals[i] = [1]*len(self.scene.values[i])
            self.vals_lp[i] = [1]*len(self.scene.values[i])
            self.affect[i] = sorted(self.scene.values[i].keys())
        self.last = time.time()
    
    def frame(self,u,values):

        #Time in 60ths of a second since last frame, so we can keep a consistant frame rate
        t60 = (time.time()-self.last)*60
        self.last = time.time()

        #It's always changing so always rerender
        self.scene.rerender = True
        if time.time()>self.ntt:
            interval= self.scene.blendArgs['interval']
            rnd=self.scene.blendArgs['rinterval']
            for k,v in enumerate(self.affect[u]):
                    nv = random.triangular(0,1,0.7)
                    self.vals[u][k] = 1-(nv*(self.scene.values[u][v]/255.0))
            self.ntt = time.time()+random.triangular(interval-rnd,interval+rnd,interval)

        lp = t60*self.scene.blendArgs['speed']
        for k,v in enumerate(self.affect[u]):
            self.vals_lp[u][k] = self.vals_lp[u][k]*(1-lp) + self.vals[u][k]*lp
            values[v] *= min((self.scene.alpha*self.vals_lp[u][k])+ 1-self.scene.alpha,255)


class sparks_blendmode():
    "Randomly jump to some of the values in this scene then fade back to what they were. Works in groups of 3 channels"
    parameters = {
                    "speed": ("Speed","number","How fast to fade out again",0.015),
                    "interval": ("Interval","number","How often to do a spark",3),
                    "variation": ("Variation","number","How much to vary the spark intensity",0.3),
                }
    def __init__(self,scene):
        self.vals_lp = {}
        self.sparktimes = {}
        self.scene = scene
        self.affect = {}
        for i in self.scene.values:
            self.vals_lp[i] = [1]*len(self.scene.values[i])
            self.affect[i] = sorted(self.scene.values[i].keys())
        self.last = time.time()

    
    def frame(self,u,values):

        #Time in 60ths of a second since last frame, so we can keep a consistant frame rate
        t60 = (time.time()-self.last)*60
        self.last = time.time()

        #It's always changing so always rerender
        self.scene.rerender = True

        lp = t60*self.scene.blendArgs['speed']
        lastv=ctr =0
        x = False
        for k,v in enumerate(self.affect[u]):
            if((not (ctr%3)) or v-lastv>1):
                ctr=0
                nv = random.triangular(1-self.scene.blendArgs['variation'],1)
                lp = max(0, random.triangular(0,lp*2,lp))
                t=time.time()
                if t>self.sparktimes.get(ctr,0):
                    c = self.scene.blendArgs['interval']
                    x = True
                    self.sparktimes[ctr]= time.time()+random.uniform(max(c/3.0,0.35),c*2)
                else:
                    x = False
    

            ctr+=1
            lastv =v
            if x:
                self.vals_lp[u][k] = nv

            self.vals_lp[u][k] = self.vals_lp[u][k]*(1-lp)
            f = self.vals_lp[u][k]*self.scene.alpha
            values[v] += min((f*self.scene.values[u][v])+ values[v]*(1-f),255)


kaithem.lights.blendmodes['sparks'] = sparks_blendmode
kaithem.lights.blendmodes['flicker'] = flicker_blendmode
kaithem.lights.blendmodes['vary'] = vary_blendmode

---
pass