allow-origins: ['*']
allow-xss: false
auto-reload: false
auto-reload-interval: 5.0
dont-show-in-index: false
mimetype: text/html
no-header: false
no-navheader: true
require-method: [GET, POST]
require-permissions: [lights/lightboard.admin]
resource-type: page
template-engine: mako

#End YAML metadata, page body mako code begins on first line after ---
---
<%!
#Code Here runs once when page is first rendered. Good place for import statements.
__doc__= ""
boardname = "default"

%>
<title>Lightboard</title>
<style>
    .grey {
        color: grey;
        font-size: 70%;
    }

    div.hfader {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
    }

    p.scene {
        border-style: solid;
        border-radius: 5px;
        border-width: 1px;
        border-color: grey;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    p.run {
        background-color: rgba(128, 190, 128, 0.4);
        !important
    }

    div.universe {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    .indicator {
        border-color: black;
        border-radius: 0.2em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        border-style: dashed;
        border-width: 1.5px;
    }

</style>
<script>
    function findMatching(l, k, v)
    {
        for (i in l)
        {
            if (l[i][k] == v)
            {
                return (i)
            }
        }
    }

</script>
<script src="${kaithem.web.resource('jquery-3.1.0')}"></script>
<script src="${kaithem.web.resource('vue-2.3.4')}"></script>
<script type="text/javascript" src="/static/widget.js"></script>
<script src="${kaithem.web.resource('keyboardjs-2.3.1')}"></script>


<script>
    function set(o, k, v)
    {

        if (o[k] == undefined)
        {
            Vue.set(o, k, v)
        }
        for (var key in v)
        {
            // If values of same property are not equal,
            // objects are not equivalent
            if (o[k][key] !== v[key])
            {
                Vue.set(o[k], key, v[key])
            }
        }

        // If we made it this far, objects
        // are considered equivalent
        return true;
    }

</script>

<div id="app">
    <a href="download" title="Download your scenes as a file">Save</a>
    <a href="upload" title="Upload a scenes file">Load</a>
    <a href="save" title="Save to the kaithem registry as the default state at boot">Make Current State the Default</a>
    <label>Show DMX Setup:
        <input type="checkbox" v-model="showDMXSetup">
    </label>

    <label>Show Fixture Types:
        <input v-on:change="showhidefixtures" type="checkbox" v-model="showFixtureSetup">
    </label>

    <label>Show Fixture Assignments:
        <input type="checkbox" v-model="showfixtureassg" v-on:change="getfixtureassg" >
    </label><br>


    <datalist id="serports">
        <option v-for="i of serports" v-bind:value="i"></option>
    </datalist>

    <div v-if="showDMXSetup" class="sectionbox">
        <h3>Universe Setup</h3>
        <p class="help">These settings are saved immediately to the Kaithem registry when you click
            "Update Settings". To save them to disk, go to the system settings page
            and save the server state to disk.</p>
        <button v-on:click="refreshPorts">Refresh Serial Ports</button>
        <button v-on:click="pushSettings">Update Settings</button><br>
        <br>

        <h4>Universe Status</h4>
        <div v-for="(v,i) in universes">
            <b>{{i}}</b>:<span v-bind:style="{'color':v.ok?'green':'red'}">{{v.status}}</span>
        </div>
        <br>

        <h4>Serial Ports</h4>
        <span v-for="i in serports">{{i}}<br></span>
        <br>

        <h4>Configure Universes
            <div v-for="(v,i) in configuredUniverses">
                <h4>{{i}}</h4>
                Type:
                <input v-model="v.type"> Interface:
                <input list="serports" v-model="v.interface" placeholder="Default"> Framerate:
                <input type=number min=0 max=480 step=0.1 v-model="v.framerate">
                Channels:<input type=number min=0 max=512 v-model="v.channels">
                <button v-on:click="deleteUniverse(i)">Del</button>
            </div>

            <input placeholder="New Universe Name" v-model="newuniversename">
            <button v-on:click="configuredUniverses[newuniversename]={type:'enttec',framerate:44,channels:512}">Add</button>

    </div>

    <div v-if="showFixtureSetup" class="sectionbox">
            <h3>Fixture Setup</h3>

            <select v-model="selectedFixtureClass" v-on:change="getfixtureclass(selectedFixtureClass)">
                <option v-for="(v,i) in fixtureClasses" :value="i">{{i}}
            </option>
            </select>
            <button v-on:click="addfixturetype">Add fixture type</button>
            <button>Rename</button>

            <h3>Channels in Fixture Type</h3>
            <div v-for="(v,i) in fixtureClasses[selectedFixtureClass]">
                <h5>{{i}}.</h5>
                <label>Name:<input v-on:change="pushfixture(selectedFixtureClass)" v-model="fixtureClasses[selectedFixtureClass][i][0]"></label>
                <label>Type:<select v-on:change="pushfixture(selectedFixtureClass)" v-model="fixtureClasses[selectedFixtureClass][i][1]" v-on:change="chTypeChanged(i)">
                    <option>red</option>
                    <option>green</option>
                    <option>blue</option>
                    <option>uv</option>
                    <option>white</option>
                    <option>intensity</option>
                    <option>custom</option>
                    <option>fine</option>
                </select></label>

                <label v-if="fixtureClasses[selectedFixtureClass][i][1]=='fine'">
                    Matching Coarse:<input v-on:change="pushfixture(selectedFixtureClass)" title="The corresponding coarse channel for this fine channel" min=0 max=64 type="number" v-model="fixtureClasses[selectedFixtureClass][i][2]">
                </label>
            </div>
            <button v-on:click="fixtureClasses[selectedFixtureClass].push(['red','red'])">Add Channel</button>

    </div>


 <div v-if="showfixtureassg" class="sectionbox">
            <h3>Fixture Assignments</h3>
            <p class="Help">Here is where you actually assign fixtures to channels after creating the desired fixture types. Clicking Update
                will cause the new assignments to take effect immediately. They are stored in the Kaithem registry, use the save server state
                button in Kaithem's settings to make them permanent.
            </p>
            <p class="help">To Create a fixture, simply add a line of the format "name, type,universe, startaddr", where name is freely chosen(letters and numbers only),
                type is an existing fixture type, universe is the name of the universe you are putting the fixture in, and startaddr is a number.</p>
            <textarea v-model="fixtureassg" rows=12 cols=45>
            </textarea>
            <div v-if="ferrs">
            <h4>Errors:</h4>
<pre>{{ferrs}}</pre>
            </div><br>

            <button v-on:click="pushfixtureassg">Update</button>
    </div>

    <div v class="sectionbox" style="float:left;overflow: auto; width:20%; height:90%; resize:both;">
        <label>
            <input size=8 title="Enter a cue's shortcut code here to activate it'" placeholder="Shortcut"
                v-model="sc_code" v-on:keydown.enter="shortcut()"></input>
        </label>
        <button v-on:click="shortcut()">Go!</button>

        <h3 title="All currently active scenes and all scenes that were created through the light board ar shown">Scenes</h3>

        <button v-on:click="scenefilter=''">X</button>
        <input v-model="scenefilter" placeholder="Search" list="tracks" />
        <button v-bind:class="{highlight:showAll==false}" v-on:click="showAll=false" title="Show all active scenes">Active</button>
        <button v-bind:class="{highlight:showAll}" v-on:click="showAll=true" title="Show all scenes owned by this board">Board</button>
        <br/>
        <div id="scene" style="overflow: scroll; max-height:450px;">
            <p v-for="i in formatScenes()" v-bind:class="{'scene':1, 'grey':i[1].doingHandoff, run:i[1].active &(!i[1].doingHandoff)}"
                style="border-style:solid; border-width:1px;">
                <button v-bind:class="{specialentry:i[0]==scenename}" v-on:click="selectscene(i[1],i[0])"><b>{{i[1].name}}</b><span v-if="i[1].ext" class="grey"> (external)</span></button>
                <span v-if="i[1].active && cuemeta[i[1].cue]">{{cuemeta[i[1].cue].name}}</span><br>
                <br>
                <button class="gobutton" v-on:click="go(i[0])">Go!</button>
                <button v-on:click="nextcue(i[0])">&gt&gt</button>
                <button class="stopbutton" v-on:click="stop(i[0])">Stop!</button>
                <button class="deletebutton" v-on:click="delscene(i[0])">del</button>
                <input type="range" max=1 step=0.01 min=0 v-on:input="setalpha(i[0],parseFloat($event.target.value));"
                    :value="alphas[i[0]]"><br>
                <cue-countdown :unixtime="unixtime" :scene="i[1]" :cue="cuemeta[i[1].cue]"></cue-countdown>
                <span v-if="cuemeta[i[1].cue]&&(cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext)">Next Cue: {{cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext}}<br></span>
                <small>Priority:<b>{{i[1].priority}}</b></small>
                <small v-if="i[1].blend!=='normal'">Blend:<b>{{i[1].blend}}</b></small>
            </p>
        </div>


        <hr>
        <input id="newscenename" placeholder="New scene name">
        <button v-on:click="addScene()">Add</button>
        <button v-on:click="addMonitorScene()">Add Monitor</button>

    </div>


    <div class="sectionbox" v-if="editingScene" style="display:inline-block; width:75%; resize:both;">
        <h3><span v-on:dblclick="promptRename(scenename)" title="Double click to set scene name"><span v-if="editingScene.blend=='monitor'">Monitor</span>            Scene: {{editingScene.name}}</span> <span class="highlight" v-if="editingScene.active&(!editingScene.doingHandoff)">(running)</span>
            Current Cue:<button v-on:click="selectedCues[scenename]=cuemeta[editingScene.cue].name">{{cuemeta[editingScene.cue].name}}</span>
            <meter v-if="editingScene.active && cuemeta[editingScene.cue].length" min=0 max=1
                v-bind:value="(unixtime-editingScene.enteredCue)/cuemeta[editingScene.cue].length"></meter>
            <button v-on:click="nextcue(scenename)">Next</button>


            <span class="virtual" v-if="editingScene.doingHandoff">(fading out)</span>
        </h3>
        <label v-if="scenecues[scenename]">Cue Select:
            <select v-model="selectedCues[scenename]" v-on:change="getcuedata(scenecues[scenename][$event.target.value])">
                <option v-for="i in formatCues()" v-bind:value="i[1].name">{{i[1].name}} ({{i[1].number}})</small>
                </option>
            </select>
        </label>
        <input v-model="newcuename" placeholder="New cue name">
        <button v-on:click="addcue(scenename,newcuename)">Add Cue</button>
        <button v-on:click="clonecue(scenename,currentcueid,newcuename)">Clone Cue</button>
        <button v-on:click="rmcue(currentcueid)">Delete Selected</button>
        <button v-on:click="jumptocue(currentcueid)">Jump to Selected</button>

        <hr>
        <div v-if="currentcue">
            <label>Number:
                <input type="number" title="Cue number" style="width:6em" v-on:input="setnumber(currentcueid,$event.target.value)"
                    v-model="currentcue.number">
            </label>

            <label>Code:
                <input title="Shortcut code used to quickly activate a cue" size="8" v-on:input="setshortcut(currentcueid,$event.target.value)"
                    v-model="currentcue.shortcut">
            </label>

            <label>Track:
                <input type="checkbox" v-on:change="settrack(currentcueid,currentcue.track)" v-model="currentcue.track"
                    title="Track values from previous cue? If false, values not present are always transparent">
            </label>

            <label>Fadein:
                <input type="number" v-on:input="setfadein(currentcueid,$event.target.value)" style="width:3em"
                    min=0 v-model="currentcue.fadein">
            </label> {{scenemeta[scenename].bpm?"beats":"s"}}

            </label>
            <label>Length:
                <input type="number" v-on:input="setlength(currentcueid,$event.target.value)" v-model="cuemeta[currentcueid].length"
                    style="width:4em" min=0></input>
            </label> {{scenemeta[scenename].bpm?"beats":"s"}}

    
            </span>


            <label>Next Cue:
                <input list="cues_in_scene" title="Select a cue to activate when this one ends" v-on:input="setnext(currentcueid,$event.target.value)"
                    v-model="cuemeta[currentcueid].next" v-bind:placeholder="currentcue.defaultnext"></input>
            </label>
            <button v-on:click="gotonext(currentcueid)">Edit Next</button>
            <button v-on:click="clonecue(scenename,currentcueid,currentcue.next)">Clone to Next</button>

            <datalist id="cues_in_scene" v-if="scenecues[scenename].length<50">
                <option v-for="i in Object.keys(scenecues[scenename]).sort()" v-bind:value="i"></option>
            </datalist>

            <label>Wait for manual advance:
                <input type="checkbox" size="16" v-on:change="setwait(currentcueid,currentcue.wait)"
                    v-model="currentcue.wait" title="Prevents automatically triggering to the next cue">
            </label>
            <hr>

            <span class="help" v-if="editingScene.ext">This is an external scene that is defined somewhere in code. Any changed made here may be overwritten by the code at any time.</span>

            <div float="right" style="overflow: scroll; max-height:30em;">
                <div class="universe" v-for="i in cuevals[currentcueid]">
                    <span v-on:dblclick="toggleTransparent(currentcueid,i.u,parseInt(i.ch),i.v)" title="Double click to toggle released">
                        <b v-if="chnamelookup(i.u,i.ch)==undefined">{{i.u}}:{{i.ch}}</b>
                        <b v-if="chnamelookup(i.u,i.ch)" v-bind:title="'Actual channel:'+i.u+':'+i.ch">{{channelNames[i.u][i.ch][0]}}.{{channelNames[i.u][i.ch][1]}}</b>
                        <small v-if="chnamelookup(i.u,i.ch)">({{channelNames[i.u][i.ch][2]}})</small>
                    </span>
                    <span v-if="i.v !== null">
                    <input v-bind:disabled="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='fine'" v-if="editingScene.blend!=='monitor'"
                        type="range" v-bind:step="(chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='fine')? 0.01:1" max=255
                        v-on:input="setCueVal(currentcueid,i.u,parseInt(i.ch),parseFloat($event.target.value))" v-model="i.v">
                    <meter v-if="editingScene.blend=='monitor'" type="range" max=255 v-bind:value="i.v"></meter>
                    </span>
                    <span v-if="i.v== null" class=grey>Released</span>



                    <span v-if="!(channelNames[i.u]&&channelNames[i.u][i.ch]&&channelNames[i.u][i.ch][2]=='fine')"
                        title="Double click to set exact value" v-on:dblclick="promptExactVal(currentcueid,i.u,parseInt(i.ch))"
                        style="font-size:80%">{{String(i.v).slice(0,6)}}</span>
                    <span class=grey title="Double click to set exact value" v-if="channelNames[i.u]&&channelNames[i.u][i.ch]&&channelNames[i.u][i.ch][2]=='fine'"
                        v-on:dblclick="promptExactVal(currentcueid,i.u,parseInt(i.ch))">auto</span>

                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='red'" v-bind:style="{'background-color': 'rgb('+i.v+ ',0,0)' , 'border-color':'red'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='green'" v-bind:style="{'background-color': 'rgb(0,'+i.v+',0)' , 'border-color':'green'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='blue'" v-bind:style="{'background-color': 'rgb(0,0,'+i.v+')'  , 'border-color':'blue'}"
                        class="indicator"></span>
                   <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='uv'" v-bind:style="{'background-color': 'rgb(i.v,0,'+i.v+')'  , 'border-color':'blue'}"
                        class="indicator"></span>
                   <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='custom'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>
                   <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='intensity'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>
                   <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='white'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>

                    <span v-if="chnamelookup(i.u,i.ch)==undefined" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}"
                        class="indicator"></span>
                    <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='custom'">{{getValueRange(chnamelookup(i.u,i.ch),i.v)[2]}}</span>
                </div>
            </div>
            <div style="clear:both">
                <input list="universes" id="newcueu" placeholder="Universe">
                <datalist id="universes">
                    <option v-for="(v,i) of universes" v-bind:value="i">({{v.count}} values)</option>
                </datalist>
                <input type="number" id="newcuevnumber" title="Channel Number" style="width:5em"
                    value="1">
                <button v-on:click="addValToCue()">Add Channel to Scene</button>
                <button v-on:click="rmValFromCue()">Remove</button>
                <label v-if="editingScene.blend=='monitor'">Priority:
                    <input type='number' min=0 max=100 style="width:3em" v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                        v-model="editingScene.priority">
                </label>

                <br><br>
                <div v-if="editingScene.blend!=='monitor'" style="border-style:solid; border-radius:5px;border-color:grey;">


                    <label>Default Alpha:
                        <input type="number" style="width:4em" max=1 step=0.01 min=0 v-on:input="setdalpha(scenename,parseFloat($event.target.value))"
                            v-model="editingScene.dalpha"></input>
                    </label>
                    <label>Blend Mode:
                        <select title="This setting controls blending multiple scenes together" v-on:input="setblend(scenename,$event.target.value)"
                            v-model="editingScene.blend">

                            <option title="Alpha blend with scenes below">normal</option>
                            <option title="Highest Takes Priority, only affect lights if the value is higher than the others">HTP</option>
                            <option title="Limit maximum level">inhibit</option>
                            <option v-for="i in ${[i for i in module.blendmodes.keys()]}">{{i}}</option>

                        </select>
                        <label>Priority:
                            <input type='number' min=0 max=100 style="width:3em" v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                                v-model="editingScene.priority">
                        </label><br>


                        <label title="Check this box to make the scene active at startup">Active By Default:
                            <input type="checkbox" v-on:change="setdactive(scenename,$event.target.checked)"
                                v-model="editingScene.defaultActive"></input>
                        </label>

                        <label title="Scenes inherit from previous scenes even if you jump directly to them">Backtrack:
                            <input type="checkbox" v-on:change="setbacktrack(scenename,$event.target.checked)"
                                v-model="editingScene.backtrack"></input>
                        </label>

                        </br>

                        <hr v-if="editingScene.blendParams !== {}" style="border-style:solid;border-width:1px;border-color:grey;">
                        <label v-for="(j,k) in editingScene.blendParams">{{j[0]}}:
                            <input type="number" style="width:5em" step=0.01 v-bind:title="j[2]" v-on:input="setblendparam(scenename,k,parseFloat($event.target.value))"
                                v-model="editingScene.blendArgs[k]"></input>

                        </label>

                </div>
            </div>
        </div>
        <div v-if="scenecues[scenename][selectedCues[scenename]]==undefined || cuemeta[scenecues[scenename][selectedCues[scenename]]]==undefined">
            Cue data not found...
        </div>

    </div>

    <section style="float:left;">
        <h3>Key Bindings</h3>
        <button v-on:click="editMode" v-bind:class="{highlight:keybindmode=='edit'}">Edit Mode</button>
        <button v-on:click="runMode" v-bind:class="{highlight:keybindmode=='run'}">Run Mode</button>
        Show Help:<input type="checkbox" v-model="showkeybindhelp">
        <p class=meubar>Current Bank: {{currentBindingBank}}</p>
        <div v-if="showkeybindhelp">
        <p class="help">
            One keybinding per line, as in space+x: go scene<br> Valid commands: <br>sc
            [shortcutcode]
            <br>go [scene]<br> stop [scene]<br>goto [scene] [cue]
            <br>next [scene]<br> toggle [scene].<br><br> To organize bindings into
            banks, <br>put the bank's name in square brackets on a line.<br> when
            the page loads, the bank is 'default'.<br> To switch banks, use the bank
            [name] command.
            <br><br>
            Use the goto command to make a scene jump to a cue. Example "a: goto scenename cuename".
            You can use either the cue number or the cue name in a binding.</br><br>
            Use sc to trigger all cues attached to a given shortcut code. Example: "a: sc code"</br>
            Use go to activate a scene, stop to stop it, and toggle to toggle it. 

        </p>
        </div>
            <p>
                <textarea rows=20 cols=20 v-model="keybindscript" v-on:focus="editMode"></textarea>
            </p>
            <button v-on:click="localStorage.setItem('keybind-script',keybindscript)">Save these keybindings to my browser as the defaults</button>


    </section>


</div>


<template id="cue-cd">
    <span>
    <meter v-bind:high=" (cue.length>30)?cue.length-10:cue.length" v-if="scene.active && cue && cue.length" min=0 v-bind:max="cue.length"
    v-bind:value="unixtime-scene.enteredCue"></meter><br>
    <span v-if="scene.active && cue && cue.length">
     Next cue in: {{formatInterval(cue.length-(unixtime-scene.enteredCue))}}
     <br>
     </span></span>
</template>
<div>

    ${module.board.link.render('api_link')}

    <script>
        formatInterval = function(seconds)
        {
            var hours = Math.floor(seconds / 3600);
            var minutes = Math.floor((seconds - (hours * 3600)) /
                60);
            var seconds = seconds - (hours * 3600) - (minutes * 60);
            var tenths = Math.floor((seconds - Math.floor(seconds)) *
                10);
            seconds = Math.floor(seconds);

            var time = "";

            time = hours + "h " + minutes + "m " + seconds + "." +
                tenths + "s"
            return time;
        }
        Vue.component('cue-countdown',
        {
            template: '#cue-cd',
            props: ['unixtime', 'cue', 'scene'],
            data: function()
            {
                return ({ 'formatInterval': formatInterval })
            }
        });

        //# sourceURL=appcode.js 
        appData = {
            //https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss
            'formatInterval': formatInterval,
            'console': console,
            'sc_code': "",
            'unixtime': 0,
            'serports': [],
            'fixtureassg':'',
            //Fixture error info str
            'ferrs':'',
            'showkeybindhelp': false,
            'showfixtureassg': false,
            'fixtureassg': '',

            'refreshPorts': function()
            {
                api_link.send(['getserports'])
            },
            'pushSettings': function()
            {
                api_link.send(['setconfuniverses', appData.configuredUniverses])
            },

            'showDMXSetup': false,
            'configuredUniverses':
            {
                'blah': { 'type': 'enttec', 'interface': 'xyz' }
            },
            'newuniversename': "",
            'fixtureClasses': {'dfjlkdjf':[]},
            'selectedFixtureClass': '',
            'showFixtureSetup':false,
            'chTypeChanged': function(i)
            {
                if(appData.fixtureClasses[appData.selectedFixtureClass][i][1]=='fine')
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass][i],2, i-1)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass][i],3,undefined)
                }
                else
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass][i],2,undefined)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass][i],3,undefined)

                }
                appData.pushfixture(i)
            },
            'getValueRange':function(d,v)
            {
                c = 0
                for (i in d)
                {
                    if(c>2)
                    {
                        if(i[0]<=v)
                        {
                            return(i)
                        }
                    }
                    c+=1
                }
                return([0,255,"Unknown"])
            },
            'pushfixture':function(i)
            {
                api_link.send(['setfixtureclass',i, appData.fixtureClasses[i]])
            },
           'pushfixtureassg':function()
            {
                api_link.send(['setfixtureassg', appData.fixtureassg])
            },
            'getfixtureassg':function()
            {
                api_link.send(['getfixtureassg'])
            },
            'showhidefixtures':function()
            {
                appData.getfixtureclasses()
                appData.selectedFixtureClass = ''
            },
            'getfixtureclasses':function()
            {
                api_link.send(['getfixtureclasses'])
            },
            'getfixtureclass':function(i)
            {
                api_link.send(['getfixtureclass',i])
            },
            'addfixturetype': function()
            {
                x =prompt("New Fixture Type Name:")
                if (x)
                {
                    Vue.set(appData.fixtureClasses,x,[])
                }
            },
            'dictView': function(dict, sorts)
            {
                //Given a dict  and a list of sort keys sorts,
                //return a list of [key,value] pairs sorted by the sort 
                //keys. Earlier sort keys take precendence.

                //Keys starting with ! are interpreted as meanng to sort in descending order

                var o = []
                Object.keys(dict).forEach(
                    function(key, index)
                    {
                        o.push([key, dict[key]])
                    })

                var l = []
                for (var i of sorts)
                {
                    //Convert to pairs reverse, string where reverse is -1 if str started with an exclamation point
                    //Get rid of the fist char if so
                    l.push([
                        i[0] == '!' ? -1 : 1,
                        i[0] == "!" ? i.slice(1) : i
                    ])
                }

                o.sort(function(a, b)
                {
                    //For each of the possible soft keys, check if they
                    //are different. If so, compare and possible reverse the ouptut

                    var d = a[1]
                    var d2 = b[1]
                    for (i of l)
                    {
                        var key = i[1]
                        var rev = i[0]
                        if (!(d[key] == d2[key]))
                        {
                            return (d[key] > d2[key] ? 1 : -1) *
                                rev
                        }

                    }
                    return 0
                });
                return (o)
            },

            'formatScenes': function()
            {
                if (!appData.showAll)
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', '!started', 'name'
                    ]).filter(
                        function(x)
                        {
                            return (x[1].name && x[1].name.includes(
                                appData.scenefilter))
                        }).filter(
                        function(x)
                        {
                            return x[1].active
                        });
                }
                else
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', 'name'
                    ]).filter(function(x)
                    {
                        return ((!x[1].ext) && ((x[1].name && x[
                            1].name.includes(
                            appData.scenefilter
                        ))))
                    })
                }

            },
            'formatCues': function()
            {
                z = {}
                //list cue objects
                for (i in appData.scenecues[appData.scenename])
                {
                    m = appData.cuemeta[appData.scenecues[appData.scenename]
                        [i]]
                    if (m !== undefined)
                    {
                        z[i] = m
                    }
                }
                return appData.dictView(z, ['number'])
            },
            'promptExactVal': function(cue, u, v)
            {
                var x = prompt("Enter new value for scene")

                if (x != null)
                {
                    if (parseFloat(x))
                    {
                        appData.setCueVal(cue, u, v, Math.max(0, Math.min(
                            parseFloat(x), 255)))
                    }
                }
            },

            'toggleTransparent': function(cue, u, c, v)
            {
                if (v != null)
                {
                    appData.setCueVal(cue, u, c, null)
                }
                else
                {
                    appData.setCueVal(cie, u, c, null)
                }
            },
            'promptRename' (s)
            {
                var x = prompt(
                    "Enter new name for scene(May break existing references to scene)"
                )

                if (x != null)
                {

                    api_link.send(['setscenename', s, x])

                }

            },
            //If false, only show active scenes
            'showAll': true,
            'deleteUniverse': function(u)
            {
                console.log(u)
                Vue.delete(appData.configuredUniverses, u)
            },
            //Filter which scenes are shown in the list
            'scenefilter': '',
            'currentBindingBank': 'default',
            'localStorage': localStorage,
            'keybindscript': localStorage.getItem("keybind-script"),
            'keybindmode': 'edit',
            //Formatted for display
            'cuevals': {},
            //Current per scene alpha channel
            'alphas': {},
            //Used only for autocompletion, it's a list of all known tracks that we've seen so far.
            'knownTracks': {},
            'scenemeta': {},
            'scenename': null,
            'editingScene': null,
            'running_scenes': {},
            'universes': {},
            'allScenes': [],
            'cues': {},
            'newcuename': '',
            'cuemeta': {},

            'selectedCues': {},
            'scenecues': {},
            //Indexed by universe then channel number
            'channelNames': {},
            //same info as scenevals, indexed hierarchally, as [universe][channel]
            //Actual objs are shared too so changing one obj change in in the other.
            'chnamelookup': function(u, c)
            {
                if (appData.channelNames[u] == undefined)
                {
                    return undefined
                }

                return appData.channelNames[u][c]
            },
            'scenedata': {},
            'setCueVal': function(sc, u, ch, val)
            {
                api_link.send(['scv', sc, u, ch, val]);
                appData.cues[sc][u][ch] = val

            },

            'selectscene': function(sc, sn)
            {
                this.getcuedata(this.scenecues[sn]['default'])
                this.editingScene = sc;
                this.scenename = sn;
                api_link.send(['gsd', sn]);
            },
            'delscene': function(sc)
            {
                var r = confirm("Really delete scene?");
                if (r == true)
                {
                    api_link.send(['del', sc]);
                }
            },

            'go': function(sc)
            {

                api_link.send(['go', sc]);
            },

            'goByName': function(sn)
            {

                api_link.send(['gobyname', sn]);
            },

            'toggleByName': function(sn)
            {

                api_link.send(['togglebyname', sn]);
            },

            'stopByName': function(sn)
            {

                api_link.send(['stopbyname', sn]);
            },

            'shortcut': function(sc)
            {
                api_link.send(['shortcut', appData.sc_code]);
                appData.sc_code = ''

            },

            'stop': function(sc, sn)
            {
                if (appData.scenemeta[sc].ext)
                {
                    var x = confirm(
                        "Really stop external scene? \nIt will dissapear from the scene listing because it is not owned by this light board.\n You may need to re-save an event to start it again."
                    )
                }
                else
                {
                    var x = true
                }
                if (x)
                {
                    api_link.send(['stop', sc]);
                }
            },
            'setalpha': function(sc, v)
            {
                api_link.send(['setalpha', sc, v]);
                appData.alphas[sc] = v
            },
            'setfade': function(sc, v)
            {

                api_link.send(['setfade', sc, v]);
            },
            'nextcue': function(sc)
            {
                api_link.send(['nextcue', sc]);
            },

            'addcue': function(sc, v)
            {
                api_link.send(['addcue', sc, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)
            },

            'clonecue': function(sc, cue, v)
            {
                api_link.send(['clonecue', cue, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)

            },
            'gotonext': function(currentcueid)
            {
                nextcue = appData.cuemeta[currentcueid].next

                cue = nextcue || (appData.cuemeta[currentcueid].defaultnext)
                if (!cue)
                {
                    return
                }
                api_link.send(['addcue', appData.scenename, nextcue]);
                api_link.send(['getcuedata', cue]);

                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[cue] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    set(appData.scenecues[appData.scenename], cue,
                        undefined);
                }
                setTimeout(function()
                    {
                        Vue.set(appData.selectedCues,
                            appData.scenename, cue)
                    },
                    30)
            },
            'rmcue': function(cue)
            {
                appData.selectedCues[appData.scenename] = 'default'
                api_link.send(['rmcue', cue]);
            },
            'jumptocue': function(cue)
            {
                api_link.send(['jumptocue', cue]);
            },
            'getcuedata': function(c)
            {

                api_link.send(['getcuedata', c]);
            },
            'getcuemeta': function(c)
            {

                api_link.send(['getcuemeta', c]);
            },
            'setnext': function(sc, cue, v)
            {
                api_link.send(['setnext', sc, cue, v]);
            },
            'setshortcut': function(cue, v)
            {
                api_link.send(['setshortcut', cue, v]);
            },
            'setnumber': function(cue, v)
            {
                api_link.send(['setnumber', cue, v]);
            },

            'setfadein': function(cue, v)
            {
                api_link.send(['setfadein', cue, v]);
            },
            'settrack': function(cue, v)
            {
                api_link.send(['settrack', cue, v]);
            },

            'setblend': function(sc, v)
            {
                api_link.send(['setblend', sc, v]);
            },
            'setblendparam': function(sc, k, v)
            {

                api_link.send(['setblendarg', sc, k, v]);
            },

            'setdactive': function(sc, v)
            {

                api_link.send(['setdefaultactive', sc, v]);
            },

            'setbacktrack': function(sc, v)
            {

                api_link.send(['setbacktrack', sc, v]);
            },
            'setlength': function(sc, v)
            {

                api_link.send(['setlength', sc, v]);
            },

            'setdalpha': function(sc, v)
            {

                appData.scenemeta[sc].alpha = v;
                api_link.send(['setdalpha', sc, v]);
            },
            'setpriority': function(sc, v)
            {
                api_link.send(['setpriority', sc, v]);
            },

            'addScene': function()
            {
                api_link.send(['addscene', $('#newscenename').val()]);
            },

            'addMonitorScene': function()
            {
                api_link.send(['addmonitor', $('#newscenename').val()]);
            },
            'addValToCue': function()
            {
                if (!$('#newcueu').val())
                {
                    return
                }
                api_link.send(['addcueval', appData.scenecues[appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    $('#newcueu').val(), parseInt($(
                        '#newcuevnumber').val())
                ]);
                $('#newcuevnumber').val(parseInt($('#newcuevnumber').val()) +
                    1)

            },
            'rmValFromCue': function()
            {
                api_link.send(['scv', appData.scenecues[appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    $('#newcueu').val(),
                    parseInt($('#newcuevnumber').val()), null
                ])
            },
            'sortscenes': function()
            {

                appData.allScenes.sort(function(a, b)
                {
                    return a[3] - b[3]
                })
            },
            'editMode': function()
            {
                keyboardJS.reset();
                appData.keybindmode = "edit";
            },
            'runMode': function()
            {
                rebind(appData.keybindscript);
                appData.keybindmode = "run";
            },
            //https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
            'isNumeric': function(input)
            {
                var RE = /^-{0,1}\d*\.{0,1}\d+$/;
                return (RE.test(input));
            }

        }


        var sceneslist = new Vue(
        {
            el: '#app',
            data: appData,
            computed:
            {
                "currentcue": function()
                {
                    return (this.cuemeta[this.scenecues[this.scenename]
                        [this.selectedCues[this.scenename]]
                    ])
                },
                "currentcueid": function()
                {
                    return (this.scenecues[this.scenename][this.selectedCues[
                        this.scenename]])
                }

            }
        })

        function f(v)
        {
            c = v[0]

            if (c == "scenemeta")
            {
                if (appData.cuemeta[v[2].cue] == undefined)
                {
                    appData.getcuemeta(v[2].cue)
                }
                Vue.set(appData.alphas, v[1], v[2].alpha);
                set(appData.scenemeta, v[1], v[2]);
                if (appData.selectedCues[v[1]] == undefined)
                {
                    Vue.set(appData.selectedCues, v[1], 'default')
                }
                //Make an empty list of cues as a placeholder till the real data arrives
                if (appData.scenecues[v[1]] == undefined)
                {
                    Vue.set(appData.scenecues, v[1], {});
                };
            }

            if (c == "cuemeta")
            {
                //Make an empty list of cues if it's not there yet
                if (appData.scenecues[v[2].scene] == undefined)
                {
                    Vue.set(appData.scenecues, v[2].scene, {});
                };
                Vue.set(appData.scenecues[v[2].scene], v[2].name, v[1]);
                set(appData.cuemeta, v[1], v[2]);
            }

            if (c == "serports")
            {
                appData.serports = v[1]
            }
            if (c == 'confuniverses')
            {
                appData.configuredUniverses = v[1]
            }
            if (c == 'universe_status')
            {
                appData.universes[v[1]].status = v[2]
                appData.universes[v[1]].ok = v[3]

            }
            if (c == "delcue")
            {
                c = appData.cuemeta[v[1]]
                Vue.delete(appData.cues, v[1]);
                Vue.delete(appData.cuemeta, v[1]);
                Vue.delete(appData.cuevals, v[1]);
                Vue.delete(appData.scenecues[c.scene], c.name);
            }

            if (c == "cnames")
            {
                Vue.set(appData.channelNames,v[1],v[2])
            }
            if (c == "universes")
            {
                appData.universes = v[1]
            }
            if (c == 'scenecues')
            {
                //Scenecues only gives us cue number and id info.
                //So if the data isn't in cuemeta, fill in what we can
                d = v[2]
                for (i in v[2])
                {
                    if (appData.cuemeta[d[i][0]] == undefined)
                    {
                        Vue.set(appData.cuemeta, d[i][0],
                        {
                            'name': i,
                            'number': d[
                                i][1]
                        })
                    }
                    Vue.set(appData.scenecues[v[1]], i, d[i][0])
                }
            }
            if (c == "cuedata")
            {
                set(appData.cues, v[1], v[2]);
                x = []
                d = {}
                for (i in v[2])
                {
                    if (!(i in appData.channelNames))
                    {
                        api_link.send(['getcnames', i])
                    }
                    d[i] = {}
                    for (j in v[2][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": v[2][i][j]
                        }
                        d[i][j] = y
                        x.push(y)
                    }
                }
                Vue.set(appData.cuevals, v[1], x)
            }
            if (c == "scv")
            {
                if (v[4] == null)
                {
                    Vue.delete(appData.cues[v[1]][v[2]], v[3])
                }
                else
                {
                    if ((appData.cues[v[1]][v[2]] == undefined) && v[4] !== null)
                    {
                        set(appData.cues[v[1]],v[2],{})
                    }
                    set(appData.cues[v[1]][v[2]], v[3], v[4]);

                }

                x = []
                for (i in appData.cues[v[1]])
                {
                    for (j in appData.cues[v[1]][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": appData.cues[v[1]][i][j]
                        }
                        x.push(y)
                    }
                }
                set(appData.cuevals, v[1], x)
            }


            if (c == "go")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', true)

            }
            if (c == "stop")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', false)

            }
            if (c == "ferrs")
            {

                appData.ferrs = v[1]

            }
            if (c == "fixtureclasses")
            {

                appData.fixtureClasses = v[1]
            }
             if (c == "fixtureclass")
            {

                Vue.set(appData.fixtureClasses, v[1],v[2])
            }
            if (c == "fixtureassg")
            {

                appData.fixtureassg = v[1]
            }
            if (c == "del")
            {
                Vue.delete(appData.selectedCues, v[1])
                Vue.delete(appData.scenemeta, v[1])
                Vue.delete(appData.scenedata, v[1])
                Vue.delete(appData.scenevals, v[1])
                Vue.delete(appData.running_scenes, v[1])
                Vue.delete(appData.mtimes, v[1])

            }

            if (c == "newscene")
            {
                appData.allScenes.push([v[1], v[2]])
            }
        }



        api_link.upd = f
        api_link.send(['gasd']);

    </script>

    <script>
        setInterval(function()
        {
            appData.unixtime = ((new Date()).getTime() /
                1000)
        }, 1000 / 14)
        var shortcut = function(sc)
        {
            return function()
            {
                api_link.send(['shortcut', sc]);

            }
        }
        var next = function(sc)
        {
            return function()
            {
                api_link.send(['nextcuebyname', sc]);

            }
        }
        var goto = function(sc, cue)
        {
            return function()
            {
                api_link.send(['jumpbyname', sc, cue]);

            }
        }
        var goScene = function(sc)
        {
            return function()
            {
                appData.goByName(sc);
            }
        }

        var toggleScene = function(sc)
        {
            return function()
            {
                appData.toggleByName(sc);
            }
        }
        var stopScene = function(sc)
        {
            return function()
            {
                appData.stopByName(sc);
            }
        }
        var switchBank = function(b)
        {
            return function()
            {
                appData.currentBindingBank = b.trim();
                rebind(appData.keybindscript);
            }
        }

        rebind = function(data)
        {
            var banks = data.split("[")
            keyboardJS.reset()
            for (var bank in banks)
            {
                var lines = banks[bank].split('\n')
                //Only happens when a bank switch line is found,
                //so everything before that is available in all banks
                if (lines[0].includes("]"))
                {

                    var firstline = lines[0].replace("]", "").trim()

                    if (firstline != appData.currentBindingBank)
                    {
                        continue;
                    }
                    lines.splice(0, 1);
                }

                for (var i in lines)
                {

                    var line = lines[i].split(":")
                    if (line[1])
                    {
                        try
                        {
                            binding = line[0].trim()
                            command = line[1].trim()
                            command = command.split(" ")
                            if (command[0] == 'go')
                            {
                                keyboardJS.bind(binding, goScene(command[1]))
                            }
                            if (command[0] == 'sc')
                            {
                                keyboardJS.bind(binding, shortcut(command[1]))
                            }
                            if (command[0] == 'goto')
                            {
                                keyboardJS.bind(binding, goto(command[1],command[2]))
                            }
                            if (command[0] == 'toggle')
                            {
                                keyboardJS.bind(binding, toggleScene(
                                    command[1]))
                            }
                            if (command[0] == 'stop')
                            {
                                keyboardJS.bind(binding, stopScene(command[
                                    1]))
                            }
                            if (command[0] == 'bank')
                            {
                                //Bank switch on key up, to make sure they run after other stuff
                                keyboardJS.bind(binding, (pass) => 0,
                                    switchBank(command[
                                        1]))
                            }
                            if (command[0] == 'next')
                            {
                                keyboardJS.bind(binding, next(command[
                                    1]))
                            }
                        }
                        catch (e)
                        {
                            alert("Bad binding script line:" + lines[i] + e)
                        }
                    }

                }
            }

        }

    </script>
