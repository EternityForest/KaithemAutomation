allow-origins: ['*']
allow-xss: false
auto-reload: false
auto-reload-interval: 5.0
dont-show-in-index: false
mimetype: text/html
no-header: false
no-navheader: true
require-method: [GET, POST]
require-permissions: [lights/lightboard.admin]
resource-type: page
template-engine: mako

#End YAML metadata, page body mako code begins on first line after ---
---
<%!
#Code Here runs once when page is first rendered. Good place for import statements.
__doc__= ""
boardname = "default"
%>
<style>
    .grey {
        color: grey;
        font-size: 70%;
    }

    div.hfader {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
    }

    p.scene {
        border-style: solid;
        border-radius: 5px;
        border-width: 1px;
        border-color: grey;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    p.run {
        background-color: rgba(128, 190, 128, 0.4);
        !important
    }

    div.universe {
        border-style: solid;
        border-radius: 5px;
        float: left;
        overflow: auto;
        border-width: 1px;
        border-color: grey;
        margin: 3px;
        display: inline-block;
        background-color: rgba(128, 128, 128, 0.4);
        !important
    }

    .indicator {
        border-color: black;
        border-radius: 0.2em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        border-style: dashed;
        border-width: 1.5px;
    }

</style>
<script>
    function findMatching(l, k, v)
    {
        for (i in l)
        {
            if (l[i][k] == v)
            {
                return (i)
            }
        }
    }

</script>
<script src="${kaithem.web.resource('jquery-3.1.0')}"></script>
<script src="${kaithem.web.resource('vue-2.3.4')}"></script>
<script type="text/javascript" src="/static/widget.js"></script>
<script src="${kaithem.web.resource('keyboardjs-2.3.1')}"></script>


<script>
    function set(o, k, v)
    {

        if (o[k] == undefined)
        {
            Vue.set(o, k, v)
        }
        for (var key in v)
        {
            // If values of same property are not equal,
            // objects are not equivalent
            if (o[k][key] !== v[key])
            {
                Vue.set(o[k], key, v[key])
            }
        }

        // If we made it this far, objects
        // are considered equivalent
        return true;
    }

</script>

<a href="download" title="Download your scenes as a file">Save</a>
<a href="upload" title="Upload a scenes file">Load</a>
<a href="save" title="Save to the kaithem registry as the default state at boot">Make Current State the Default</a>


<div id="app">

    <div v class="sectionbox" style="float:left;overflow: auto; width:20%; height:90%; resize:both;">

        <h3 title="All currently active scenes and all scenes that were created through the light board ar shown">Scenes</h3>

        <button v-on:click="scenefilter=''">X</button>
        <input v-model="scenefilter" placeholder="Search" list="tracks" />
        <button v-bind:class="{highlight:showAll==false}" v-on:click="showAll=false" title="Show all active scenes">Active</button>
        <button v-bind:class="{highlight:showAll}" v-on:click="showAll=true" title="Show all scenes owned by this board">Board</button>
        <br/>
        <div id="scene" style="overflow: scroll; max-height:450px;">
            <p v-for="i in formatScenes()" v-bind:class="{'scene':1, 'grey':i[1].doingHandoff, run:i[1].active &(!i[1].doingHandoff)}"
                style="border-style:solid; border-width:1px;">
                <b v-if="i[1].active">^</b>
                <button v-bind:class="{specialentry:i[0]==scenename}" v-on:click="selectscene(i[1],i[0])"><b>{{i[1].name}}</b><span v-if="i[1].ext" class="grey"> (external)</span></button>
                <button class="gobutton" v-on:click="go(i[0])">Go!</button>
                <button class="stopbutton" v-on:click="stop(i[0])">Stop!</button>
                <button class="deletebutton" v-on:click="delscene(i[0])">del</button><br>
                <input type="range" max=1 step=0.01 min=0 v-on:input="setalpha(i[0],parseFloat($event.target.value));" :value="alphas[i[0]]"><br>
                <small>Priority:<b>{{i[1].priority}}</b></small> <small v-if="i[1].blend!=='normal'">Blend:<b>{{i[1].blend}}</b></small>
                
            </p>
        </div>


        <hr>
        <input id="newscenename" placeholder="New scene name"> <button v-on:click="addScene()">Add</button>
        <button v-on:click="cloneScene()">Clone Selected</button><button v-on:click="addMonitorScene()">Add Monitor</button>

    </div>


    <div class="sectionbox" v-if="editingScene" style="display:inline-block; width:75%; resize:both;">
        <h3><span v-on:dblclick="promptRename(scenename)" title="Double click to set scene name"><span v-if="editingScene.blend=='monitor'">Monitor</span>            Scene: {{editingScene.name}}</span> <span class="highlight" v-if="editingScene.active&(!editingScene.doingHandoff)">(running)</span>
            <span class="virtual" v-if="editingScene.doingHandoff">(fading out)</span>
        </h3>
        <label>Cue Select:
            <select v-model="selectedCues[scenename]" v-on:change="Vue.set(selectedCues,scenename,$event.value)">
                <option v-for="(v,i) in scenecues[scenename]">{{i}}</option>
            </select>
            <input v-model="newcuename" placeholder="New cue name">
            <button v-on:click="addcue(scenename,newcuename)">Add Cue</button>
            <button v-on:click="rmcue(scenecues[scenename][selectedCues[scenename]])">Delete Current</button>

        </label><br>

                <label>Fadein:
            <input size="16" v-on:input="setfadein(scenecues[scenename][selectedCues[scenename]],$event.target.value)" 
                    v-model="cuefadein" >
        </label>

        </label>
                <label>Length: <input size=15
                          v-on:input="setlength(scenecues[scenename][selectedCues[scenename]],$event.target.value)"
                         v-model="cuemeta[scenecues[scenename][selectedCues[scenename]]].length"
                          ></input>
        </label>
                <label>Fadeout:
            <input size="16" v-on:input="setfadeout(scenecues[scenename][selectedCues[scenename]],$event.target.value)" 
                 v-model="cuemeta[scenecues[scenename][selectedCues[scenename]]].fadeout" > 
        </label>

                <label>Next Cue:
                    <input title="Select a scene to activate when this one ends, or before then if overlap>0"
                                    v-on:input="setnext(scenecues[scenename][selectedCues[scenename]],$event.target.value)"
                                    v-model="cuemeta[scenecues[scenename][selectedCues[scenename]]].nextCue"
                    ></input>
                </label>
        <hr>

        <span class="help" v-if="editingScene.ext">This is an external scene that is defined somewhere in code. Any changed made here may be overwritten by the code at any time.</span>

        <div float="right" style="overflow: scroll; max-height:30em;">
            <div class="universe" v-for="i in cuevals[scenecues[scenename][selectedCues[scenename]]]">
                <b v-if="chnamelookup(i.u,i.ch)==undefined">{{i.u}}:{{i.ch}}</b>
                <b v-if="chnamelookup(i.u,i.ch)" v-bind:title="'Actual channel:'+i.u+':'+i.ch">{{channelNames[i.u][i.ch][0]}}.{{channelNames[i.u][i.ch][1]}}</b>
                <small v-if="chnamelookup(i.u,i.ch)">({{channelNames[i.u][i.ch][2]}})</small>
                <input v-bind:disabled="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='fine'" v-if="editingScene.blend!=='monitor'"
                    type="range" v-bind:step="(chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='fine')? 0.01:1" max=255 v-on:input="setCueVal(scenecues[scenename][selectedCues[scenename]],i.u,parseInt(i.ch),parseFloat($event.target.value))"
                    v-model="i.v">
                <meter v-if="editingScene.blend=='monitor'" type="range" max=255 v-bind:value="i.v"></meter>

                <span v-if="!(channelNames[i.u]&&channelNames[i.u][i.ch]&&channelNames[i.u][i.ch][2]=='fine')" title="Double click to set exact value"
                    v-on:dblclick="promptExactVal(scenename,i.u,parseInt(i.ch))" style="font-size:80%">{{String(i.v).slice(0,6)}}</span>
                <span class=grey title="Double click to set exact value" v-if="channelNames[i.u]&&channelNames[i.u][i.ch]&&channelNames[i.u][i.ch][2]=='fine'"
                    v-on:dblclick="promptExactVal(scenename,i.u,parseInt(i.ch))">auto</span>

                <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='red'" v-bind:style="{'background-color': 'rgb('+i.v+ ',0,0)' , 'border-color':'red'}"
                    class="indicator"></span>
                <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='green'" v-bind:style="{'background-color': 'rgb(0,'+i.v+',0)' , 'border-color':'green'}"
                    class="indicator"></span>
                <span v-if="chnamelookup(i.u,i.ch)&&chnamelookup(i.u,i.ch)[2]=='blue'" v-bind:style="{'background-color': 'rgb(0,0,'+i.v+')'  , 'border-color':'blue'}"
                    class="indicator"></span>

                <span v-if="chnamelookup(i.u,i.ch)==undefined" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}" class="indicator"></span>
            </div>
        </div>
        <div style="clear:both">
            <input list="universes" id="newcueu" placeholder="Universe">
            <datalist id="universes">
                    <option v-for="(v,i) of universes" v-bind:value="i">({{v}} values)</option>
                </datalist>
            <input type="number" id="newcuevnumber" title="Channel Number" style="width:5em" value="1">
            <button v-on:click="addValToCue()">Add Channel to Scene</button>
            <button v-on:click="rmValFromCue()">Remove</button>
            <label v-if="editingScene.blend=='monitor'">Priority:<input type='number' min=0 max=100
                     style="width:3em"
                          v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                          v-model="editingScene.priority"
                                            ></label>

            <br><br>
            <div v-if="editingScene.blend!=='monitor'" style="border-style:solid; border-radius:5px;border-color:grey;">


                <label>Default Alpha:
 <input type="number"  style="width:4em"
                          max=1 step=0.01 min=0
                          v-on:input="setdalpha(scenename,parseFloat($event.target.value))"
                          v-model="editingScene.dalpha"
        ></input></label>
                <label>Blend Mode:
 <select title="This setting controls blending multiple scenes together"
                          v-on:input="setblend(scenename,$event.target.value)"
                          v-model="editingScene.blend"
        >

        <option title="Alpha blend with scenes below">normal</option>
        <option title="Highest Takes Priority, only affect lights if the value is higher than the others">HTP</option>
        <option title="Limit maximum level">inhibit</option>
        <option v-for="i in ${[i for i in module.blendmodes.keys()]}">{{i}}</option>

            
        </select>
    




                <label>Overlap:
 <input type="number" 
  style="width:5em"
                          max=30 step=0.05 min=0
                          v-on:input="setoverlap(scenename,parseFloat($event.target.value))"
                          v-model="editingScene.overlap"
        ></input></label>



                <label>Priority:<input type='number' min=0 max=100
                     style="width:3em"
                          v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                          v-model="editingScene.priority"
                                            ></label><br>


                <label title="Check this box to make the scene active at startup">Active By Default:
         <input type="checkbox" 
                          
                          v-on:change="setdactive(scenename,$event.target.checked)"
                          v-model="editingScene.defaultActive"
        ></input></label></br>
                <hr v-if="editingScene.blendArgs.length" style="border-style:solid;border-width:1px;border-color:grey;">
                <label v-for="(j,k) in editingScene.blendParams">{{j[0]}}:
                        <input type="number"  style="width:5em" step=0.01 v-bind:title="j[2]"
                          v-on:input="setblendparam(scenename,k,parseFloat($event.target.value))"
                          v-model="editingScene.blendArgs[k]"
                        ></input>
        
        </label>

            </div>
        </div>

    </div>

    <section style="float:left;">
        <h3>Key Bindings</h3>
        <button v-on:click="editMode" v-bind:class="{highlight:keybindmode=='edit'}">Edit Mode</button>
        <button v-on:click="runMode" v-bind:class="{highlight:keybindmode=='run'}">Run Mode</button>
        <p class=meubar>Current Bank: {{currentBindingBank}}</p>
        <p class=help>One keybinding per line, as in space+x: go scene<br> Valid commands: <br>go [scene]<br> stop [scene]<br> next [track]<br>            stoptrack [track]<br> toggle [scene].<br><br> To organize bindings into banks, <br>put the bank's name in square
            brackets on a line.<br> when the page loads, the bank is 'default'.<br> To switch banks, use the bank [name]
            command.
            <p>
                <textarea rows=20 cols=20 v-model="keybindscript" v-on:focus="editMode"></textarea>
            </p>
            <button v-on:click="localStorage.setItem('keybind-script',keybindscript)">Save these keybindings to my browser as the defaults</button>


    </section>


</div>


<div>

    ${module.board.link.render('api_link')}

    <script>
        appData = {
            'dictView': function(dict, sorts)
            {
                //Given a dict  and a list of sort keys sorts,
                //return a list of [key,value] pairs sorted by the sort 
                //keys. Earlier sort keys take precendence.

                //Keys starting with ! are interpreted as meanng to sort in descending order

                var o = []
                Object.keys(dict).forEach(
                    function(key, index)
                    {
                        o.push([key, dict[key]])
                    })

                var l = []
                for (var i of sorts)
                {
                    //Convert to pairs reverse, string where reverse is -1 if str started with an exclamation point
                    //Get rid of the fist char if so
                    l.push([
                        i[0] == '!' ? -1 : 1,
                        i[0] == "!" ? i.slice(1) : i
                    ])
                }

                o.sort(function(a, b)
                {
                    //For each of the possible soft keys, check if they
                    //are different. If so, compare and possible reverse the ouptut

                    var d = a[1]
                    var d2 = b[1]
                    for (i of l)
                    {
                        var key = i[1]
                        var rev = i[0]
                        if (!(d[key] == d2[key]))
                        {
                            return (d[key] > d2[key] ? 1 : -1) * rev
                        }

                    }
                    return 0
                });
                return (o)
            },

            'formatScenes': function()
            {
                if (!appData.showAll)
                {
                    return appData.dictView(appData.scenemeta, ['!priority', '!started', 'name']).filter(
                        function(x)
                        {
                            return (x[1].name && x[1].name.includes(appData.scenefilter))
                        }).filter(
                        function(x)
                        {
                            return x[1].active
                        });
                }
                else
                {
                    return appData.dictView(appData.scenemeta, ['!priority', 'name']).filter(function(x)
                    {
                        return ((!x[1].ext) && ((x[1].name && x[1].name.includes(appData.scenefilter))))
                    })
                }

            },
            'promptExactVal': function(s, u, v)
            {
                var x = prompt("Enter new value for scene")

                if (x != null)
                {
                    if (parseFloat(x))
                    {
                        appData.setSceneVal(s, u, v, Math.max(0, Math.min(parseFloat(x), 255)))
                    }
                }
            },
            'promptRename' (s)
            {
                var x = prompt("Enter new name for scene(May break existing references to scene)")

                if (x != null)
                {

                    api_link.send(['setscenename', s, x])

                }

            },
            //If false, only show active scenes
            'showAll': true,
            //Filter which scenes are shown in the list
            'scenefilter': '',
            'currentBindingBank': 'default',
            'localStorage': localStorage,
            'keybindscript': localStorage.getItem("keybind-script"),
            'keybindmode': 'edit',
            //Formatted for display
            'cuevals': {},
            //Current per scene alpha channel
            'alphas': {},
            //Used only for autocompletion, it's a list of all known tracks that we've seen so far.
            'knownTracks': {},
            'scenemeta': {},
            'scenename': null,
            'editingScene': null,
            'running_scenes': {},
            'universes': {},
            'allScenes': [],
            'cues': {},
            'newcuename':'',
            'cuemeta': {},

            'selectedCues': {},
            'scenecues': {},
            //Indexed by universe then channel number
            'channelNames': {},
            //same info as scenevals, indexed hierarchally, as [universe][channel]
            //Actual objs are shared too so changing one obj change in in the other.
            'chnamelookup': function(u, c)
            {
                if (appData.channelNames[u] == undefined)
                {
                    return undefined
                }

                return appData.channelNames[u][c]
            },
            'scenedata': {},
            'setCueVal': function(sc, u, ch, val)
            {
                api_link.send(['scv', sc, u, ch, val]);

            },

            'selectscene': function(sc, sn)
            {
                this.editingScene = sc;
                this.scenename = sn;
                api_link.send(['gsd', sn]);
            },
            'delscene': function(sc)
            {
                var r = confirm("Really delete scene?");
                if (r == true)
                {
                    api_link.send(['del', sc]);
                }
            },

            'go': function(sc, sn)
            {

                api_link.send(['go', sc]);
            },

            'goByName': function(sn)
            {

                api_link.send(['gobyname', sn]);
            },

            'toggleByName': function(sn)
            {

                api_link.send(['togglebyname', sn]);
            },

            'stopByName': function(sn)
            {

                api_link.send(['stopbyname', sn]);
            },



            'stop': function(sc, sn)
            {
                if (appData.scenemeta[sc].ext)
                {
                    var x = confirm(
                        "Really stop external scene? \nIt will dissapear from the scene listing because it is not owned by this light board.\n You may need to re-save an event to start it again."
                    )
                }
                else
                {
                    var x = true
                }
                if (x)
                {
                    api_link.send(['stop', sc]);
                }
            },
            'setalpha': function(sc, v)
            {
                api_link.send(['setalpha', sc, v]);
                appData.alphas[sc]=v
            },
            'setfade': function(sc, v)
            {

                api_link.send(['setfade', sc, v]);
            },

            'addcue': function(sc, v)
            {
                api_link.send(['addcue', sc, v]);
            },
            'rmcue': function(cue)
            {
                appData.selectedCues[appData.scenename]='default'
                api_link.send(['rmcue', cue]);
            },
            'setoverlap': function(sc, v)
            {

                api_link.send(['setoverlap', sc, v]);
            },

            'setnext': function(sc,cue, v)
            {
                api_link.send(['setnext', sc, cue, v]);
            },
 
          
            'setfadein': function(cue,v)
            {
                api_link.send(['setfadein',cue, v]);
            },
            'setfadeout': function(sc, cue,v)
            {

                api_link.send(['setfadeout', cue, v]);
            },



            'setblend': function(sc, v)
            {
                api_link.send(['setblend', sc, v]);
            },
            'setblendparam': function(sc, k, v)
            {

                api_link.send(['setblendarg', sc, k, v]);
            },

            'setdactive': function(sc, v)
            {

                api_link.send(['setdefaultactive', sc, v]);
            },
            'setlength': function(sc, v)
            {

                api_link.send(['setlength', sc, v]);
            },
    
            'setdalpha': function(sc, v)
            {

                appData.scenemeta[sc].alpha = v;
                api_link.send(['setdalpha', sc, v]);
            },
            'setpriority': function(sc, v)
            {
                api_link.send(['setpriority', sc, v]);
            },

            'addScene': function()
            {
                api_link.send(['addscene', $('#newscenename').val()]);
            },

            'addMonitorScene': function()
            {
                api_link.send(['addmonitor', $('#newscenename').val()]);
            },

            'cloneScene': function()
            {
                api_link.send(['clonescene', appData.scenename, $('#newscenename').val()]);
            },
            'addValToCue': function()
            {
                api_link.send(['addcueval', appData.scenecues[appData.scenename][appData.selectedCues[appData.scenename]], $('#newcueu').val(), parseInt($(
                    '#newcuevnumber').val())]);
            },
            'rmValFromCue': function()
            {
                api_link.send(['rmcueval', appData.selectedCues[appData.scenename], $('#newcueu').val(), parseInt($(
                    '#newcuevnumber').val())]);
            },
            'sortscenes': function()
            {

                appData.allScenes.sort(function(a, b)
                {
                    return a[3] - b[3]
                })
            },
            'editMode': function()
            {
                keyboardJS.reset();
                appData.keybindmode = "edit";
            },
            'runMode': function()
            {
                rebind(appData.keybindscript);
                appData.keybindmode = "run";
            },
            //https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
            'isNumeric': function(input)
            {
                var RE = /^-{0,1}\d*\.{0,1}\d+$/;
                return (RE.test(input));
            }

        }


        var sceneslist = new Vue(
        {
            el: '#app',
            data: appData,
            computed:
            {
                "cuefadein": function(){
                    return(this.cuemeta[this.scenecues[this.scenename][this.selectedCues[this.scenename]]].fadein)
                    }
            }
        })

        function f(v)
        {
            c = v[0]

            if (c == "scenemeta")
            {
                //Vue.set(appData.alphas, v[1], v[2].alpha);
                set(appData.scenemeta, v[1], v[2]);
                if (appData.selectedCues[v[1]] == undefined)
                {
                    Vue.set(appData.selectedCues,v[1],'default')
                }
            }

            if (c == "cuemeta")
            {
                set(appData.scenecues[v[2].scene],v[2].name, v[1]);
                set(appData.cuemeta, v[1], v[2]);
            }

            if (c == "cuedata")
            {
                set(appData.cues, v[1], v[2]);
            }
            if (c == "delcue")
                {
                    Vue.delete(appData.cues, v[1]);
                    Vue.delete(appData.cuemeta, v[1]);
                    Vue.delete(appData.cuevals, v[1]);
                    Vue.delete(appData.scenecues[v[2].scene],v[2].name);
                }

            if (c == "ssv")
            {
                Vue.set(appData.scenedata[v[1]][v[2]][v[3]], 'v', v[4])
            }
            if (c == "cnames")
            {
                appData.channelNames[v[1]] = v[2]
            }
            if (c == "universes")
            {
                appData.universes = v[1]
            }
            if (c == 'scenecues')
            {
                Vue.set(appData.scenecues, v[1], v[2])
            }
            if (c == "cuedata")
            {
                x = []
                d = {}
                for (i in v[2])
                {
                    if (!(i in appData.channelNames))
                    {
                        api_link.send(['getcnames', i])
                    }
                    d[i] = {}
                    for (j in v[2][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": v[2][i][j]
                        }
                        d[i][j] = y
                        x.push(y)
                    }
                }
                Vue.set(appData.cuevals, v[1], x)
                Vue.set(appData.cuedata, v[1], d)
            }

            if (c == "go")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', true)

            }
            if (c == "stop")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', false)

            }
            if (c == "tracks")
            {

                Vue.set(appData.tracks, 'tracks', v[1])

            }

            if (c == "del")
            {
                Vue.delete(appData.selectedCues, v[1])
                Vue.delete(appData.scenemeta, v[1])
                Vue.delete(appData.scenedata, v[1])
                Vue.delete(appData.scenevals, v[1])
                Vue.delete(appData.running_scenes, v[1])
                Vue.delete(appData.mtimes, v[1])

            }

            if (c == "newscene")
            {
                appData.allScenes.push([v[1], v[2]])
            }
        }



        api_link.upd = f
        api_link.send(['gasd']);

    </script>

    <script>
        var goScene = function(sc)
        {
            return function()
            {
                appData.goByName(sc);
            }
        }

        var toggleScene = function(sc)
        {
            return function()
            {
                appData.toggleByName(sc);
            }
        }
        var stopScene = function(sc)
        {
            return function()
            {
                appData.stopByName(sc);
            }
        }
        var switchBank = function(b)
        {
            return function()
            {
                appData.currentBindingBank = b.trim();
                rebind(appData.keybindscript);
            }
        }

        rebind = function(data)
        {
            var banks = data.split("[")
            keyboardJS.reset()
            for (var bank in banks)
            {
                var lines = banks[bank].split('\n')
                //Only happens when a bank switch line is found,
                //so everything before that is available in all banks
                if (lines[0].includes("]"))
                {

                    var firstline = lines[0].replace("]", "").trim()

                    if (firstline != appData.currentBindingBank)
                    {
                        continue;
                    }
                    lines.splice(0, 1);
                }

                for (var i in lines)
                {

                    var line = lines[i].split(":")
                    if (line[1])
                    {
                        try
                        {
                            binding = line[0].trim()
                            command = line[1].trim()
                            command = command.split(" ")
                            if (command[0] == 'go')
                            {
                                keyboardJS.bind(binding, goScene(command[1]))
                            }
                            if (command[0] == 'toggle')
                            {
                                keyboardJS.bind(binding, toggleScene(command[1]))
                            }
                            if (command[0] == 'stop')
                            {
                                keyboardJS.bind(binding, stopScene(command[1]))
                            }
                            if (command[0] == 'bank')
                            {
                                keyboardJS.bind(binding, switchBank(command[1]))
                            }
                        }
                        catch (e)
                        {
                            alert("Bad binding script line:" + lines[i] + e)
                        }
                    }

                }
            }

        }

    </script>
