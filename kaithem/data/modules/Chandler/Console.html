---
allow-origins: ['*']
allow-xss: false
auto-reload: false
auto-reload-interval: 5.0
dont-show-in-index: false
mimetype: text/html
no-header: false
no-navheader: true
require-method: [GET, POST]
require-permissions: [users.chandler.admin]
resource-timestamp: 1640654205728206
resource-type: page
template-engine: mako

---
<%!
#Code Here runs once when page is first rendered. Good place for import statements. 
__doc__= ""
boardname = "default"
import json
from src import tagpoints
%>

<datalist name="midiinputs" id="midiinputs">
    %for i in module.listRtmidi():
    <option>${i|h}</option>
    %endfor
</datalist>

<datalist name="nextcueoptions" id="nextcueoptions">
    <option>default</option>
    <option></option>
    <option>__random__</option>
    <option>__shuffle__</option>
</datalist>


<%
limitedTagsListing=module.limitedTagsListing()
%>
        <title>Chandler Console</title>

        <style>
            /*https://allthingssmitty.com/2016/10/03/responsive-table-layout/*/
            
            @media screen and (max-width: 820px) {
                table.reflow tr {
                    border-bottom: 3px solid #ddd;
                    display: block;
                    margin-bottom: 1em;
                }
                table.reflow thead {
                    display: none;
                }
                table.reflow td {
                    border-bottom: 1px solid #ddd;
                    display: block;
                    text-align: right;
                }
                td.rowname {
                    font-size: 135%;
                    font-weight: bold;
                }
                table.reflow td::before {
                    content: attr(data-label);
                    float: left;
                }
                td {
                    font-family: B612;
                }
            }
        </style>
        <style>
            .grey {
                color: grey;
                font-size: 70%;
            }
            
            div.hfader {
                border-style: solid;
                border-radius: 5px;
                overflow: auto;
                border-width: 2px;
                border-color: rgba(0,0,0,0.1);
                margin: 3px;
                float: left;
                width: 15em;
                height: 2em;
            }
            
            div.hfader input {
                float: right;
            }
            
            div.hfader span.indicator {
                float: right;
            }
            
            .fadersbox {
                background-color: rgba(200, 200, 255, 0.1);
            }
            
            .evlisting {
                background-color: rgba(180, 230, 200, 0.8);
            }
            
            .evlisting_err {
                background-color: rgba(220, 180, 30, 0.8);
            }
            
            p.scene {
                border-style: solid;
                border-radius: 5px;
                border-width: 1px;
                border-color: grey;
                background-color: rgba(128, 128, 128, 0.4);
                !important
            }
            
            p.run {
                background-color: rgba(128, 190, 128, 0.4);
                !important
            }
            
            div.universe {
                border-style: solid;
                border-radius: 5px;
                float: left;
                overflow: auto;
                border-width: 1px;
                border-color: grey;
                margin: 3px;
                width: 95%;
                display: inline-block; //background-color: rgba(128, 128, 128, 0.4);
                !important
            }
            
            div.fixture {
                border-style: solid;
                border-radius: 5px;
                float: left;
                overflow: auto;
                border-width: 2px;
                border-color: darkgrey;
                margin: 3px;
                display: inline-block;
                background-color: rgba(128, 128, 128, 0.4);
                !important
            }
            
            .indicator {
                border-color: black;
                border-radius: 0.2em;
                display: inline-block;
                width: 0.9em;
                height: 0.9em;
                border-style: dashed;
                border-width: 1.5px;
            }
            
            label {
                display: inline-block;
                border: 0px;
                margin: 3px;
                border-radius: 0px;
                padding: 0px;
                border: 0px;
                margin:3px 8px 3px 8px
            }
            label>input{
                border-radius: 0px;
                border: 1px solid rgba(0,0,0,0.3);
                margin: 0px;
            }
            
            .labelbox {
                display: flex;
                flex-wrap: wrap;
            }
            
            .break {
                flex-basis: 100%;
                height: 0;
            }
            
            .blinking {
                animation: blinkingText 1s infinite;
            }
            
            @keyframes blinkingText {
                0% {
                    opacity: 0.5;
                }
                50% {
                    opacity: 1;
                }
                100% {
                    opacity: 0.5;
                }
            }
        </style>

        <script src="/static/js/vue2.js"></script>
        <script src="/static/js/http-vue-loader.js"></script>

        <script src="/static/js/sortable.min.js"></script>
        <script src="/static/js/vuedraggable.umd.min.js"></script>

        <script type="text/javascript" src="/static/widget.js"></script>
        <script src="/static/js/keyboard.min.js"></script>
        <script src="/static/js/js-yaml.min.js"></script>

        <script src="ui/cuetable.jsvue"></script>


        <script>
            function set(o, k, v)
    {

        if (o[k] == undefined)
        {
            Vue.set(o, k, v)
        }
        for (var key in v)
        {
            // If values of same property are not equal,
            // objects are not equivalent
            if (o[k][key] !== v[key])
            {
                Vue.set(o[k], key, v[key])
            }
        }

        // If we made it this far, objects
        // are considered equivalent
        return true;
    }

    function useBlankDescriptions(l, additional)
    {
        var l2=[];
        for(i in l)
        {
            l2.push([i,'']);
        }
        if(additional)
        {
            for(i in additional)
            {
                l2.push([i,additional[i]]);

            }
        }
        return l2;
    }


        </script>


        <link rel="stylesheet" href="/static/img/icons/iconicss/iconicss.min.css">
        <link rel="stylesheet" href="/static/img/icons/fontawesome/css/fontawesome-all.min.css">


        <div id="app">
            <div v-if="showevents" class="sectionbox flex-item" style="position:fixed; z-index:99; bottom:0px; width:78%;">
                <h2> <button v-on:click="showevents=0"><img src="/zipstatic/img/icons/fugue.zip/cross-button.png"></img>Close</button>Event
                    Log
                </h2>
                <input v-model="evfilt" placeholder="Filter events"><label>Autoscroll<input type="checkbox" v-model="eventlogautoscroll"></label><br>
                <div class="scrollbox" id="eventlogbox" style="height:6em">
                    <div v-bind:class="{'evlisting': i[0]!=='error', 'evlisting_err': i[0].includes('error')}" v-for="i in evlog" v-if="i[1].search(evfilt)>-1 || i[0].search(evfilt)>-1">{{i[2]}}: <b>{{i[0]}}</b> at {{i[1]}}: 
                    
                    <span v-if="!(typeof(i[3])=='string' && i[3].length>32)">{{i[3]}}</span>
                        <pre v-if="(typeof(i[3])=='string' && i[3].length>32)">{{i[3]}}</pre>
                        <pre v-if="i[4]">{{i[4]}}</pre>
                    </div>
                </div>

                <label>Send Global Event:
            <input v-model="evtosend" v-on:keydown.enter="sendev" placeholder="Event Name" title="Event Name">
        </label>

                <input v-model="evval" v-on:keydown.enter="sendev" title="Event Value" placeholder="value">

                <select v-model="evtypetosend">
                <option value="int">Integer</option>
                <option value="float">Real Number</option>
                <option value="str">Text</option>
            </select>

                <button v-on:click="sendev('__global__')">Send</button>
            </div>


            <div id="optionsblock" class="menubar" style="display:flex;flex-wrap:wrap;">
                
                <div class="menubar buttonbar" style="background-color:rgba(255,255,255,0.1); padding:0.25em; border-color:grey; border-width:2px;">

                            <button v-on:click="saveToDisk()" title="Save the scenes to disk as the default when the Lightboard boots, but not the universes or fixtures."><img src="/zipstatic/img/icons/fugue.zip/quill.png"></img>Save Scenes as the Default</a>
                            <button v-on:click="saveSetup()" title="Save the fixtures and universes to disk as the default when the Lightboard boots"><img src="/zipstatic/img/icons/fugue.zip/quill.png"></img>Save Setup as the Default</a>
                </div>


        <div class="menubar buttonbar" style="background-color:rgba(255,255,255,0.1); padding:0.25em; border-color:grey; border-width:2px;">

        <button v-on:click="showDMXSetup=!showDMXSetup"><img src="/zipstatic/img/icons/fugue.zip/globe-green.png"></img>Universes</button>
                    <button v-on:click="showhidefixtures"><img src="/zipstatic/img/icons/fugue.zip/traffic-light--pencil.png"></img> Fixture Types</button>
                    <button v-on:click="showhidefixtureassignments"><img src="/zipstatic/img/icons/fugue.zip/light-bulb.png"></img>Fixtures</button>
                    <button v-if="showAdvancedControls" v-on:click="showevents=!showevents"><img src="/zipstatic/img/icons/fugue.zip/application-terminal.png"></img>Events</button>
                    <button v-on:click="showimportexport=!showimportexport"><img src="/zipstatic/img/icons/fugue.zip/folder-horizontal-open.png"></img>Import/Export</button>
                    <button v-on:click="showsoundmixer=!showsoundmixer"><img src="/zipstatic/img/icons/fugue.zip/speaker.png"></img>Sound</button>
                    <button v-on:click="showtags=!showtags"><img src="/zipstatic/img/icons/fugue.zip/application-terminal.png"></img>Tags</button>

                    <a class="button" href="/pages/Chandler/docs/index" target="_blank"><img src="/zipstatic/img/icons/fugue.zip/book-question.png">Help</a>
                    <a class="button" href="/pages/Chandler/Setup"><img src="/zipstatic/img/icons/fugue.zip/gear.png">Settings</a>
                </div>

                <div class="menubar buttonbar" style="background-color:rgba(255,255,255,0.1); padding:0.25em; border-color:grey; border-width:2px;">
                    <p><b>Keys:</b></p>
                    <button v-on:click="editMode" v-bind:class="{highlight:keybindmode=='edit'}"><img src="/zipstatic/img/icons/fugue.zip/pencil.png"></img>Edit Mode</button>
                    <button v-on:click="runMode" v-bind:class="{highlight:keybindmode=='run'}"><img src="/zipstatic/img/icons/fugue.zip/tick-octagon.png"></img>Send Events</button>
                </div>

            </div>


            <datalist id="serports">
                <option v-for="i of serports" v-bind:value="i"></option>
            </datalist>



            <datalist id="tagslisting">
                %for i in limitedTagsListing:
                <option value="${i}"></option>
                %endfor
            </datalist>

            <div v-if="showimportexport" class="sectionbox flex-item">
                <h3>Import/Export controls</h3>
                <div class="buttonbar" style="background-color:rgba(255,255,255,0.1);padding:0.25em; border-color:grey; border-width:2px;"><b>Download:</b>
                    <a class="button" href="download" title="Download your scenes as a file"><img src="/zipstatic/img/icons/fugue.zip/disk.png"></img>Scenes</a>
                    <a class="button" href="downloadSetup" title="Download your scenes as a file"><img src="/zipstatic/img/icons/fugue.zip/disk.png"></img>Setup</a>
                    <a class="button" href="downloadLibrary" title="Download your scenes as a file"><img src="/zipstatic/img/icons/fugue.zip/disk.png"></img>Fixture Lib</a>
                </div>
                
                <div class="buttonbar" style="background-color:rgba(255,255,255,0.1); padding:0.25em; border-color:grey; border-width:2px;"><b>Upload:</b>

                    <a class="button" href="upload" title="Upload a scenes file"><img src="/zipstatic/img/icons/fugue.zip/folder-horizontal-open.png"></img>Scenes</a>
                    <a class="button" href="uploadSetup" title="Upload a scenes file"><img src="/zipstatic/img/icons/fugue.zip/folder-horizontal-open.png"></img>Setup</a>
                    <a class="button" href="uploadLibrary" title="Upload a scenes file"><img src="/zipstatic/img/icons/fugue.zip/folder-horizontal-open.png"></img>Fixture Lib</a>
                </div>
            </div>


            <div v-if="showsoundmixer" class="sectionbox flex-item" style="width:50%; height:30em; resize:both;float:right;">
                <iframe src="/settings/mixer?kaithem_disable_header=true"  style="width:100%; height:100%; " ></iframe>
            </div>


            <div v-if="showtags" class="sectionbox flex-item" style="width:49%; height:30em; resize:both;float:right;">
                <iframe src="/tagpoints?kaithem_disable_header=true" style="width:100%; height:100%;"></iframe>
            </div>



            <div v-if="showDMXSetup" class="sectionbox flex-item">
                <h3>
                    <button v-on:click="showDMXSetup=0">
                <img src="/zipstatic/img/icons/fugue.zip/cross-button.png"></img>Close</button> Universe Setup</h3>
                <p class="help">These settings take effect immediately when you click "Update Settings". To save them to disk,
                    use "save setup" Note: Configuring these universes requires /admin/settings.edit,
                    however you do not need that permission to use the lightboard after it's configured.</p>
                <button v-on:click="refreshPorts">Refresh Serial Ports</button>
                <button v-on:click="pushSettings">Update Settings</button><br>
                <br>

                <h4>Universe Status</h4>
                <table border="1">
                    <tr>
                        <th>Universe</th>
                        <th>Status</th>
                    </tr>
                    <tr v-for="(v,i) in universes">
                        <td>{{i}}</td>
                        <td v-bind:style="{'color':v.ok?'green':'red'}">{{v.status}}</td>
                    </tr>
                </table>
                <br>

                <h4>Serial Ports</h4>
                <span v-for="i in serports">{{i}}<br></span>
                <br>

                <h4>Configure Universes</h4>
                <p>If tag point universes do nothing, check that the priority is not just being overrriden. It should be at least 50.  Also note that you should avoid using this to create new tags,
                    as they may be destroyed and recreated as cues come and go, which could cause odd behavior.   To add tags to a universe, use the extra options button. 
                </p>
                <datalist id="artnettargets">
                    %if kaithem.web.hasPermission("/admin/settings.edit"): 
                    %for i in kaithem.devices: 
                    %if hasattr(kaithem.devices[i],"pclient"):
                    <option value="pavillion://${i}:6454"></option>
                    %endif 
                    %endfor 
                    %endif
                </datalist>

                <datalist id="utypes">
                    <option value="enttecopen" title="Enttec Open DMX and most cheap FTDI based adapters, or raw serial ports"></option>
                    <option value="tagpoints" title="Control tagpoints based on the values"></option>
                    <option value="smartbulb" title="A smart bulb from kaithem's device manager'"></option>

                    <option value="enttec"></option>
                    <option value="artnet"></option>
                </datalist>

                <table border=1>
                    <tr>
                        <th>Universe</th>
                        <th>Type</th>
                        <th>Interface</th>
                        <th>Framerate</th>
                        <th>Channels</th>
                        <th>Number(artnet)/Priority(tags)</th>
                        <th>Actions</th>
                        <th>Actions</th>

                    </tr>
                    <tr v-for="(v,i) in configuredUniverses">
                        <td>{{i}}</td>
                        <td>
                            <input list="utypes" v-model="v.type" title="The type of universe. Usually enttec or artnet">
                        </td>

                        <td v-if="v.type!='artnet'">
                            <input list="serports" v-model="v.interface" title="The interface device that describes where to send the data. Usually a serial port, or a device name from the device manager for smartbulbs"
                                placeholder="Default">
                        </td>
                        <td v-if="v.type=='artnet'">
                            <input list="artnettargets" v-model="v.interface" title="A destination ip:port in the case of ArtNet. A Pavillion device name prefixed with pavillion:// may be used instead of a hostname. The IP will be obtained from the Device config"
                                placeholder="Default">
                        </td>


                        <td>
                            <input type=number min=0 max=480 step=0.1 v-model="v.framerate" title="The max frame rate">
                        </td>

                        <td>
                            <input type=number min=0 max=512 v-model="v.channels" title="The number of channels to send">
                        </td>

                        <td>
                            <input type=number min=0 max=65535 v-model="v.number" title="The universe number. Mostly used for ArtNet">
                        </td>



                        <td>
                            <button v-on:click="universeFullSettings=i">More Options</button>
                        </td>

                        <td>
                            <button v-on:click="deleteUniverse(i)">Del</button>
                        </td>
                    </tr>
                </table>
                <input placeholder="New Universe Name" v-model="newuniversename">
                <button v-on:click="configuredUniverses[newuniversename]={type:'enttec',framerate:44,channels:512, number:1, channelConfig:{}}">Add</button>


            </div>



            <div v-if="universeFullSettings" class="sectionbox flex-item">
                <h3><button v-on:click="universeFullSettings=0"><img src="/zipstatic/img/icons/fugue.zip/cross-button.png"></img>Close</button>Universe
                    Setup:{{universeFullSettings}}</h3>

                <div v-if="configuredUniverses[universeFullSettings].type=='tagpoints'">
                    <p class="help">
                        Tagpoint universes use a configurable set of tagpoints as the outputs. This table lets you assign tags to channels. Assigning
                        tags to channels requires admin permissions unless the tag begins with /chandler. You can give channels names in addition
                        to numbers by using number:name syntax.
                    </p>
                    <table border="1">
                        <tr>
                            <th>Channel Number</th>
                            <th>Tagpoint Name</th>
                            <th>Action</th>
                        </tr>
                        <tr v-for="(v,i) in configuredUniverses[universeFullSettings]['channelConfig'] || {}">
                            <td><b>{{i}}</b></td>
                            <td><input v-model="configuredUniverses[universeFullSettings]['channelConfig'][i]" list="tagslisting"></td>
                            <td><button v-on:click="delete configuredUniverses[universeFullSettings]['channelConfig'][i]">Delete</button></td>

                        </tr>

                        <tr>
                            <td><input  placeholder="CH # or number:Name" v-model="newTagPointChannelNumber"></td>
                            <td><input placeholder="Tagpoint" v-model="newTagPoint" list="tagslisting"></td>
                            <td><button v-on:click="configuredUniverses[universeFullSettings]['channelConfig'][newTagPointChannelNumber]=newTagPoint">Add</button></td>
                        </tr>


                    </table>

                </div>
            </div>



            <div v-if="showFixtureSetup" class="sectionbox flex-item">
                <h3><button v-on:click="showhidefixtures()"><img src="/zipstatic/img/icons/fugue.zip/cross-button.png"></img>Close</button>Fixture
                    Setup</h3>

                <combo-box v-model="selectedFixtureClass" v-on:change="getfixtureclass(selectedFixtureClass)" :options="useBlankDescriptions(fixtureClasses)"></combo-box>
                <button v-on:click="addfixturetype"><img src="/zipstatic/img/icons/fugue.zip/plus-octagon-frame.png"></img>Add fixture type</button>

                <div v-if="selectedFixtureClass">

                    <button v-on:click="delfixturetype"><img src="/zipstatic/img/icons/fugue.zip/minus-octagon-frame.png"></img>Delete Fixture Type</button>

                    <button>Rename</button>
                    <h4>Edit as Code</h4>
                    <button title="Update the textbox with the current fixture data(reload)" v-on:click="fixturecode=JSON.stringify(fixtureClasses[selectedFixtureClass]);$event.target.rows=15;">Fixture > Code(reload)</button>
                    <button title="Update the fixture data with the code in the textbox" v-on:click="saveFixtureTypeFromCode(selectedFixtureClass,fixturecode);">Code > Fixture(save)</button>
                    <br>
                    <textarea v-model="fixturecode" rows=1 columns=40></textarea>
                    <h3>Channels in Fixture Type</h3>
                    <div v-for="(v,i) in fixtureClasses[selectedFixtureClass]">
                        <h4>{{i}}.</h4>
                        <label>Name:
                    <input v-on:change="pushfixture(selectedFixtureClass)" v-model="fixtureClasses[selectedFixtureClass][i][0]">
                </label>
                        <label>Type:
                    <select v-on:change="pushfixture(selectedFixtureClass)" v-model="fixtureClasses[selectedFixtureClass][i][1]"
                        v-on:change="chTypeChanged(i)">
                        <option>red</option>
                        <option>green</option>
                        <option>blue</option>
                        <option>uv</option>
                        <option>white</option>
                        <option>intensity</option>
                        <option>custom</option>
                        <option>fine</option>
                        <option>unused</option>

                    </select>
                </label>

                        <label v-if="fixtureClasses[selectedFixtureClass][i][1]=='fine'">
                    Matching Coarse:
                    <input v-on:change="pushfixture(selectedFixtureClass)" title="The corresponding coarse channel for this fine channel"
                        min=0 max=64 type="number" v-model="fixtureClasses[selectedFixtureClass][i][2]">
                </label>

                        <div v-if="fixtureClasses[selectedFixtureClass][i][1]=='custom'">
                            <p class="Help">
                                The custom channel type allows you to define a different meaning for a channel depending on what range it is in. This is
                                fairly common for controlling gobos and gobo rotation, etc. Ranges are defined my the inclusive min and max channel
                                of that range, plus a name for that option.</p>
                            </p>
                            <h5>Ranges for channel {{i}}</h5>
                            <table border="1">
                                <tr>
                                    <th>Min Val</th>
                                    <th>Max Val</th>
                                    <th>Option Name</th>
                                    <th>Actions</th>
                                </tr>
                                <tr v-for="(w,j) in fixtureClasses[selectedFixtureClass][i].slice(2)">
                                    <td>
                                        <input v-on:change="pushfixture(selectedFixtureClass)" v-model.number="fixtureClasses[selectedFixtureClass][i][j+2][0]" type="number">
                                    </td>
                                    <td>
                                        <input v-on:change="pushfixture(selectedFixtureClass)" v-model.number="fixtureClasses[selectedFixtureClass][i][j+2][1]" type="number">
                                    </td>
                                    <td>
                                        <input v-on:change="pushfixture(selectedFixtureClass)" v-model.number="fixtureClasses[selectedFixtureClass][i][j+2][2]">
                                    </td>
                                    <td>
                                        <button v-on:click="del(fixtureClasses[selectedFixtureClass][i],j+2);pushfixture(selectedFixtureClass)">Del</button>
                                    </td>
                                </tr>
                            </table>
                            <button v-on:click="fixtureClasses[selectedFixtureClass][i].push([0,0,'optionName']);pushfixture(selectedFixtureClass)">Add Range</button>
                        </div>
                    </div>
                    <button v-on:click="fixtureClasses[selectedFixtureClass].push(['red','red']);pushfixture(selectedFixtureClass);">Add Channel</button>
                </div>
            </div>


            <div v-if="showfixtureassg" class="sectionbox flex-item">

                <h3>
                    <button v-on:click="showfixtureassg=0"><img src="/zipstatic/img/icons/fugue.zip/cross-button.png"></img>Close</button>                    Fixture Assignments
                </h3>
                <p class="Help">Here is where you actually assign fixtures to channels after creating the desired fixture types. Clicking Update will
                    cause the new assignments to take effect immediately. Use the save settings button to make them permanent.
                <p class="help">To Create a fixture, using codesimply add a line of the format "name, type,universe, startaddr", where name is freely
                    chosen(letters and numbers only), type is an existing fixture type, universe is the name of the universe you are putting
                    the fixture in, and startaddr is a number.</p>


                <p class="help">To Delete, just remove the line. You can also use the "Easy View" form to very quickly add and delete fixtures.</p>

                <h4>Code View</h4>
                <textarea v-model="fixturescode" rows=12 cols=45>
        </textarea>
                <div>
                    <button v-on:click="pushfixturescode">Save Code Changes</button>
                    <button v-on:click="getfixtureassg">Reload Fixtures</button>
                </div>

                <h4>Easy View</h4>

                <table border="1">
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Universe</th>
                        <th>Start Address</th>
                        <th>Delete</th>
                    </tr>

                    <tr v-for="i in dictView(fixtureAssignments,['universe', 'channel'])">
                        <td>{{i[1].name}}</td>
                        <td>{{i[1].type}}</td>
                        <td><input v-on:change="setFixtureAssignment(i[1].name, i[1])" v-model="i[1].universe"></td>
                        <td><input v-on:change="setFixtureAssignment(i[1].name, i[1])" v-model="i[1].addr"></td>
                        <td><button v-on:click="rmFixtureAssignment(i[1].name)">Delete</button>

                    </tr>
                </table>

                <table border="1">

                    <tr>
                        <td>Name:</td>
                        <td><input v-model="newfixname"></input>
                        </td>
                        <tr>
                            <td>Type:</td>
                            <td>
                                <select v-model="newfixtype">
                <option v-for="(v,i) in fixtureClasses" v-bind:value="i">{{i}}</option>
            </select>

                            </td>
                            <tr>
                                <td>Universe:</td>
                                <td><input v-model="newfixuniverse" list="universes"></input>
                                </td>
                                <tr>
                                    <td>Address:</td>
                                    <td><input type="number" min=1 v-model="newfixaddr"></input>
                                    </td>
                </table>
                <button v-on:click="addFixtureAssignment(newfixname,newfixtype,newfixuniverse, newfixaddr)">Add and Update</button>

                <div v-if="ferrs">
                    <h4>Errors:</h4>
                    <pre>{{ferrs}}</pre>
                </div><br>

            </div>

            <div v class="sectionbox flex-item" style="float:left;overflow: auto; width:20%; min-width: 15em; height:90%; resize:both;">
                
                    <div class="buttonbar"><label>
            <input size=8 title="Enter a cue's shortcut code here to activate it. Keybindings are suspended while this is selected." placeholder="Shortcut"
                v-model="sc_code" v-on:keydown.enter="shortcut()" v-on:focus="keyboardJS.pause();" v-on:blur="keyboardJS.resume();"></input>
        </label>
                <button v-on:click="shortcut()">Go!</button>
                </div>

                <h3 title="All currently active scenes and all scenes that were created through the light board ar shown">Scenes</h3>
                <p class="buttonbar">
                <input v-model="scenefilter" placeholder="Search" list="tracks" /><button v-on:click="scenefilter=''">X</button>
                </p>
                <hr>

                <p class="buttonbar">
                <button v-bind:class="{highlight:showAll==false}" v-on:click="showAll=false" title="Show all active scenes">Show All Active</button>
                <button v-bind:class="{highlight:showAll}" v-on:click="showAll=true" title="Show all scenes owned by this board">Board</button>
                </p>
                <br/>
                <div id="scene" style="overflow: scroll; max-height:450px;">
                    <div v-for="i in formatScenes()" v-if="i" style="position:relative;border:1px solid;" v-bind:class="{'scene':1, 'grey':i[1].doingHandoff, 'run':i[1].active &(!i[1].doingHandoff)}"
                        style="border-style:solid; border-width:1px;">
                        <div class="buttonbar">

                        <button v-bind:class="{specialentry:i[0]==scenename}" v-on:click="selectscene(i[1],i[0])" style="font-weight:bold;"><i v-if="i[1].syncKey" class="icss-wifi" style="color:blue;"> </i>

                    {{i[1].name}}:<span v-if="i[1].ext" class="grey"> (external)</span>
                                 

                        <span v-if="i[1].active && cuemeta[i[1].cue]">{{cuemeta[i[1].cue].name}}</span>
                    <img v-if="cuemeta[i[1].cue].sound" src="/zipstatic/img/icons/fugue.zip/speaker.png"></img> 


                    <img v-if="cuemeta[i[1].cue].inheritRules" src="/zipstatic/img/icons/fugue.zip/application-terminal.png" title="This cue has rules inherited"  v-on:click="scenetab='logic';selectcue(scenename,cuemeta[i[1].cue].name)"></img>
                    <img v-if="cuemeta[i[1].cue].rules && cuemeta[i[1].cue].rules.length>0" src="/zipstatic/img/icons/fugue.zip/application-terminal.png" title="This cue has rules attatched"  v-on:click="scenetab='logic';selectcue(scenename,cuemeta[i[1].cue].name)"></img>
                    </button>

                    
                    </div>
                        <p class="buttonbar">
                        <button v-on:click="go(i[0])"><i class="icss-arrow-right" style="color:green;"></i>Go!</button>
                        <button v-on:click="nextcue(i[0])"><i class="fas fa-forward" style="color:lightgreen"></i>Next</button>
                        <button class="stopbutton" v-on:click="stop(i[0])"><i class="fas fa-stop" style="color:darkgrey"></i>Stop</button>
                        <button class="deletebutton" v-on:click="delscene(i[0])">del</button>
                        </p>
                        <input type="range" max=1 step=0.01 min=0 v-on:input="setalpha(i[0],parseFloat($event.target.value));" v-on:change="unlockAlpha(i[0]);" :value="alphas[i[0]]"><br>
                        
                        <cue-countdown :unixtime="unixtime" :scene="i[1]" :cue="cuemeta[i[1].cue]"></cue-countdown>
                        <span v-if="cuemeta[i[1].cue]&&(cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext)">Next Cue: {{cuemeta[i[1].cue].next||cuemeta[i[1].cue].defaultnext}}
                 
                        <small v-if="i[1].priority!=50">Priority:<b>{{i[1].priority}}</b></small>
                        <small v-if="i[1].blend!=='normal'">Blend:<b>{{i[1].blend}}</b></small>
                        <small v-if="cuemeta[i[1].cue]&&(cuemeta[i[1].cue].sound) & showSoundControls"><br>Sound:<b>{{cuemeta[i[1].cue].sound.match(/([^\/]+)$/)[1]}}</b></small>

                    </div>
                </div>


                <hr>
                <p class="buttonbar">
                <input v-model="newscenename" placeholder="New scene name">
                <button v-on:click="addScene()"><img src="/zipstatic/img/icons/fugue.zip/plus-octagon-frame.png"></img>Add</button>
                <button v-on:click="addMonitorScene()"><img src="/zipstatic/img/icons/fugue.zip/binocular--plus.png"></img>Add Monitor</button>
                </p>

            </div>


        <div class="sectionbox flex-item" v-if="editingScene && cuemeta[editingScene.cue]" style="display:inline-block; width:75%; max-width:98vw; resize:both; overflow:auto;">
            <h3><span v-on:dblclick="promptRename(scenename)" title="Double click to set scene name">
                <span v-if="editingScene.blend=='monitor'">Monitor</span>
                </span> {{editingScene.name}}</span>
                <span class="highlight" v-if="editingScene.active&(!editingScene.doingHandoff)">(running)</span>
                <p v-if="editingScene.status">STATUS: {{editingScene.status}}</p>

                </h3>
                
                 <p style="background-color:rgba(250,250,250,0.5)" class="buttonbar">
                        <button v-bind:class="{highlight:scenetab=='cue'}" v-on:click="scenetab='cue'">Normal View</button>
                        <button v-bind:class="{highlight:scenetab=='sound'}" v-on:click="scenetab='sound'">Sound View</button>
                        <button v-bind:class="{highlight:scenetab=='channels'}" v-on:click="scenetab='channels'">Add/Remove Channels</button>
                        <button v-bind:class="{highlight:scenetab=='blend'}" v-on:click="scenetab='blend'">Scene Settings</button>

                        <button v-if="showAdvancedControls" v-bind:class="{highlight:scenetab=='data'}" v-on:click="scenetab='data'" title="Direct copy and pastable access to cue data"> Cue Data</button>
                        <button v-if="showAdvancedControls" v-bind:class="{highlight:scenetab=='logic'}" v-on:click="scenetab='logic'" title="If/then automation rules"> Cue Logic</button>
                        <button v-if="showAdvancedControls" v-bind:class="{highlight:scenetab=='sync'}" v-on:click="scenetab='sync'"> Scene Sync</button>
                        <button v-bind:class="{highlight:scenetab=='notes'}" v-on:click="scenetab='notes'"> Scene Notes</button>
                        <a class="button" v-bind:href="'downloadOneScene?id='+scenename+'&name='+editingScene.name" title="Download your scenes as a file"><img src="/zipstatic/img/icons/fugue.zip/disk.png"></img>Download Scene</a>

                    <input v-model="cuefilter" placeholder="Search Cues" />
                    <button v-on:click="cuefilter=''">X</button>
                                        </p>

                <hr>


                <div id="cuesbox" v-if="scenetab !='blend' && scenetab !='page'">

                    <hr>
                    <div style="overflow-y: scroll;max-height:12em;">
                        <table class="reflow" border="1" style="resize:both; width:100%;">

                            <thead>
                                <tr>
                                    <th title="Click the cue name to edit that cue">Cue Name</th>
                                    <th>Number</th>
                                    <th>Shortcut</th>
                                    <th>Fadein</th>
                                    <th title="Length, 0 indicates until stopped">Length</th>
                                    <th title="The next cue, after this one ends">Next</th>
                                    <th>Randomize</th>
                                    <th>Track</th>
                                    <th>Jump to</th>
                                </tr>
                            </thead>

                            <tbody>
                                <tr v-for="i in formatCues(1)" v-if="i[1].id" v-bind:style="{'background-color':((selectedCues[scenename]==i[1].name)?'#82d972bf':'')}">
                                    <td class="rowname" data-label="Cue: " style=" user-select: none;" title="Click the cue name to edit that cue" v-on:click="selectcue(scenename,i[1].name)"><i v-if="cuemeta[editingScene.cue].name==i[1].name" class="fas fa-play-circle" style="color:green;"></i>
                                        <img v-if="selectedCues[scenename]==i[1].name" src="/zipstatic/img/icons/fugue.zip/pencil.png"></img>
                                        <b>{{i[1].name}}</b>
                                        <img v-if="i[1].inheritRules" title="This cue has rules inherited"  v-on:click="scenetab='logic';selectcue(scenename,i[1].name)" src="/zipstatic/img/icons/fugue.zip/application-terminal.png"></img>
                                        <img v-if="i[1].rules && i[1].rules.length>0" title="This cue has rules attatched"  v-on:click="scenetab='logic';selectcue(scenename,i[1].name)" src="/zipstatic/img/icons/fugue.zip/application-terminal.png"></img>
                                    </td>

                                    <td data-label="Cue #:"><b title="Cue number, double click to change." style="width:6em" v-on:dblclick="promptsetnumber(i[1].id)">{{i[1].number}}</b></td>

                                    <td data-label="Shortcut:">
                                        <p class="buttonbar">
                                        <input title="Shortcut code" style="width:6em" v-on:change="apiCommand(i[1].id,'setshortcut',$event.target.value)" min=0 step=0.1 v-model="i[1].shortcut">
                                        <button style="opacity:0.3" title="Generate a shortcut code from the cue's number" v-on:click="apiCommand(i[1].id,'setshortcut','__generate__from__number__')">GEN</button>
                                        </p>
                                    </td>

                                    <td data-label="Fade In:">
                                        <input type="number" v-on:input="setfadein(i[1].id,$event.target.value)" style="width:3em" min=0 v-model="i[1].fadein">{{(scenemeta[scenename].bpm&&scenemeta[scenename].bpm!=60)?"beats":"s"}}</td>

                                    <td data-label="Length:">
                                        <input v-on:change="setlength(i[1].id,$event.target.value)" style="width:6em" v-model="i[1].length">{{(scenemeta[scenename].bpm&&scenemeta[scenename].bpm!=60)?"beats":"s"}}{{i[1].rel_len ?"+sound":""}}</td>

                                    <td data-label="Next Cue:">
                                        <select style="width:100%" v-model="i[1].next" v-if="Object.keys(scenecues[scenename]).length<600" autocomplete=off title="Select a cue to activate when this one ends"
                                            v-on:input="setnext(i[1].id,$event.target.value)">
                                            <option value="">&gt&gt&gt</option>
                                            <option v-for="j in formatCues(1)" v-bind:value="j[1].name">{{j[1].number}}: {{j[1].name}}</option>
                                            <option v-bind:value="i[1].next">Current: {{i[1].next}}</option>

                                            <option value="__random__">RANDOM</option>
                                            <option value="__shuffle__">SHUFFLE</option>

                                            </select>

                                            <input v-if="Object.keys(scenecues[scenename]).length>40" autocomplete=off list="cues_in_scene" title="Select a cue to activate when this one ends"
                                                v-on:input="setnext(i[1].id,$event.target.value)" v-model="i[1].next" v-bind:placeholder="i[1].defaultnext">
                                                </input>
                                    </td>



                                    <td data-label="Randomize">
                                        <input type="number" v-on:input="setrandomize(i[1].id,$event.target.value)" style="width:3em" min=0 v-model="i[1].lengthRandomize">{{scenemeta[scenename].bpm?"beats":"s"}}</td>
                                    <td data-label="Track vals from prev: ">
                                        <input type="checkbox" v-on:change="settrack(i[1].id,i[1].track)" v-model="i[1].track" title="Track values from previous cue? If false, values not present are always transparent">
                                    </td>
                                    <td data-label="Goto:">
                                        <button v-on:click="jumptocue(i[1].id)">Go</button>
                                    </td>

                                </tr>
                            </tbody>

                        </table>
                    </div>
                


                <p class="buttonbar">
                    <input v-model="newcuename" placeholder="New cue name">
                    <button v-on:click="addcue(scenename,newcuename)">
                <img src="/zipstatic/img/icons/fugue.zip/plus-octagon-frame.png"></img>Add Cue</button>
                    <button v-on:click="clonecue(scenename,currentcueid,newcuename)">
                <img src="/zipstatic/img/icons/fugue.zip/document-copy.png"></img>Clone Cue</button>
                    <button v-on:click="rmcue(currentcueid)">
                <img src="/zipstatic/img/icons/fugue.zip/minus-circle.png"></img>Delete Current</button>
            </p>
            </div>

              <hr>
                   

                <div v-if="currentcue && scenetab !='blend' && scenetab !='page'">
                    <h3>Editing Cue: {{currentcue.name}}</h3>

                    <span class="help" v-if="editingScene.ext">This is an external scene that is defined somewhere in code. Any changes made here may be overwritten by the code at any time.</span>

                    <div style="overflow: scroll; max-height:30em;" class="fadersbox" v-if="showLightingControls&&(scenetab!='logic')">
                        <div class="universe" v-for="(h,uname) in cuevals[currentcueid]" v-if="uname[0]!='@'" style="border-style:solid">
                            <h3>{{uname}}</h3>
                            <h-fader :i="i" :chinfo="chnamelookup(i.u,i.ch)" :monitor="editingScene.blend=='monitor'" :currentcueid="currentcueid" :showdelete="scenetab=='channels'"
                                v-for="i in h"></h-fader>
                        </div>


                        <div class="fixture" v-for="(h,fname) in cuevals[currentcueid]" v-if="fname[0]=='@'" style="border-style:solid">
                            <h4>{{fname}}</h4>
                            <button v-on:click="rmFixCue(currentcueid, fname)">
                            <img src="/zipstatic/img/icons/fugue.zip/minus-circle.png">
                        </button>
                            <h-fader :i="i" :chinfo="chnamelookup(i.u,i.ch)" :monitor="editingScene.blend=='monitor'" :currentcueid="currentcueid" :showdelete="scenetab=='channels'"
                                v-for="i in h"></h-fader>
                        </div>
                    </div>

                    <div style="overflow: scroll; max-height:30em;" v-if="scenetab=='notes'">
                        <h4>Scene Notes</h4>
                        <textarea v-model:value="editingScene.notes"></textarea><br>
                        <button v-on:click="setSceneNotes(scenename,editingScene.notes)">Save</button>
                    </div>


                    <div style="overflow: scroll; max-height:30em;" class="logicbox" v-if="scenetab=='logic'">
                        <div>
                            <h3>Automation Logic</h3>
                            <p class="help">Here you can create rules that apply whenever the scene is in this cue, to do things like trigger other cues when
                                this one enters or exits.
                                <a href="/pages/Chandler/docs/RulesEngine">Documentation</a>
                            </p>
                        </div>
                        <div>
                            <label>Inherit rules from cue in same scene:
                            <combo-box v-model="currentcue.inheritRules" v-on:change="setCueInheritRules(currentcueid, currentcue.inheritRules)" :options="useBlankDescriptions(scenecues[scenename])"></combo-box>

                            </label>
                        </div>
                        <script-editor v-bind:example_events="example_events" v-model="currentcue.rules" v-on:input="setCueRules(currentcueid, $event);" v-bind:commands="availableCommands"
                            v-bind:scenes="cueNamesBySceneName()" v-bind:pinnedvars="specialvars" v-bind:vars="editingScene.vars" v-bind:parentscene="editingScene.name"> </script-editor>
                            <div style="display:flex;flex-wrap:wrap;">
                                <div style="border-style:solid;flex-grow:3;margin:0.5em;padding:0.5em;">
                                    <h3>Scene Variables</h3>
                                    <table border="1">

                                        <tr v-for="(v,i) in editingScene.vars">
                                            <td>{{i}}</td>
                                            <td>{{v}}</td>
                                            <tr>
                                    </table>
                                </div>

                                <div style="border-style:solid;flex-grow:1;margin:0.5em;padding:0.5em;">
                                    <h3>Timers</h3>
                                    <table border="1" style="width:100%">

                                        <tr v-for="(v,i) in editingScene.timers">
                                            <td>{{i}}</td>
                                            <td style="width:8em;" v-bind:class="{highlight:(v-unixtime)<60, blinking:(v-unixtime)<5}">
                                                {{formatInterval((v-unixtime))}}
                                            </td>
                                            <tr>
                                    </table>
                                </div>
                            </div>
                            <h3>Event Log</h3>
                             <div class="scrollbox" id="eventlogbox" style="height:6em">
                                <div v-bind:class="{'evlisting': i[0]!=='error', 'evlisting_err': i[0].includes('error')}" v-for="i in evlog" v-if="i[0].search(editingScene.name)">{{i[2]}}: <b>{{i[0]}}</b> at {{i[1]}}: 
                                
                                <span v-if="!(typeof(i[3])=='string' && i[3].length>32)">{{i[3]}}</span>
                                    <pre v-if="(typeof(i[3])=='string' && i[3].length>32)">{{i[3]}}</pre>
                                    <pre v-if="i[4]">{{i[4]}}</pre>
                                </div>
                            </div>

                    </div>




                    <div>





                        <div v-if="scenetab=='channels'">
                            <h4>Add Channel by Universe and Name/Number</h4>
                            <combo-box v-bind:options="useBlankDescriptions(universes)" v-model="newcueu"></combo-box>
                            <combo-box v-bind:options="getChannelCompletions(newcueu)" v-model="newcuevnumber"></combo-box>


                            <button v-on:click="addValToCue()"><img src="/zipstatic/img/icons/fugue.zip/plus-octagon-frame.png"></img>Add Channel to Cue</button>

                            <h4>Add Fixture</h4>

                            <table>
                                <tr v-for="(v,i) in fixtures">
                                    <td>{{v[0]}}:{{i}} at {{v[1]}}</td>
                                    <td><button v-on:click="addThisFixToCurrentCue(i)"><img src="/zipstatic/img/icons/fugue.zip/plus-octagon-frame.png"></img>Add</button></td>
                                </tr>
                            </table>

                            <label v-if="editingScene.blend=='monitor'">Priority:
                        <input type='number' min=0 max=100 style="width:3em" v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                            v-model="editingScene.priority">
                        </label>
                        </div>


                        <div v-if="scenetab=='data'">
                            <textarea rows=50 cols=25 v-model="cuedatafield" v-on:change="setcuevaldata(currentcueid,$event.target.value)">
                        
                    </textarea>
                        </div>

                        <div v-if="scenetab=='sync'">
                            <h3>Sync Options</h3>
                            <p class="help">
                                The Pavillion protocol is now removed!! Nobody was using this. Stay tuned for MQTT sync at some point.
                            </p>

                        </div>

                        <div v-if="scenetab=='sound'">
                            <div>
                                <label>Sound:
                            <input placeholder="No sound file" v-model="currentcue.sound" style="width:32em;"
                                v-on:change="setSoundfile(currentcueid,currentcue.sound)">
                        </label><br>
                                <label>Device:<a target="_blank" href="/settings/mixer">(mixer)</a>
                                
                                <datalist id="soundcards">
                                <option v-for="i of soundCards" v-bind:value="i"></option>
                                <option value="@auto"></option>
                                <option value="@pulse:hw:0,0"></option>
                                <option value="@alsa:hw:0,0"></option>

                                </datalist>


                            <input title="Using mplayer -ao syntax, or one of kaithem's device aliases, set the output device" v-on:input="setSoundOutput(currentcueid,$event.target.value)"
                                v-model="cuemeta[currentcueid].soundOutput" placeholder="default" list="soundcards"></input>
                        </label><br>


                        <label>Length relative to sound:
                            <input type="checkbox" v-on:change="setrellen(currentcueid,currentcue.rel_len)" v-model="currentcue.rel_len"
                                title="If checked, the length parameter is interpreted as a delay after the sound cue ends.">
                        </label>



                        <label>Fade sound after end(If going to silence):
                            <input type="number" v-on:input="setSoundFadeOut(currentcueid,$event.target.value)" style="width:3em"
                                min=0 v-model="currentcue.soundFadeOut"
                                title="Sound should fade out starting when the cue ends, taking this long. Only works on the suggested GStreamer backend"
                                >{{scenemeta[scenename].bpm?"beats":"s"}}
                                
                        </label><br>
                        

                        <label>Sound fade in(If silence before):
                            <input type="number" v-on:input="setSoundFadeIn(currentcueid,$event.target.value)" style="width:3em"
                                min=0 v-model="currentcue.soundFadeIn"
                                title="Sound should fade in if starting from, taking this long. Only works on the suggested GStreamer backend. Use crossfade to control fading from another sound."
                                >{{scenemeta[scenename].bpm?"beats":"s"}}
                                
                        </label>

                        <label>Volume modifier for this cue(=expression allowed):
                            <input v-on:change="setCueVolume(currentcueid,$event.target.value)" style="width:5em"
                                min=0 v-model="currentcue.soundVolume"
                                >
                        </label>
                        
                         <label>Loop Sound(-1 for forever)
                            <input v-on:change="setCueLoops(currentcueid,$event.target.value)" style="width:5em"
                                min=-1 v-model="currentcue.soundLoops"
                                >
                        </label>
                        
                        
                        <br>
                            </div>
                                <p class="buttonbar">
                                <input v-model="soundsearch" v-on:change="soundsearchresults=[]" v-on:keyup.enter="doSoundSearch(soundsearch)" placeholder="Filter Sounds"
                                style="width:60%;">
                                <button v-on:click="doSoundSearch(soundsearch)">Search</button>
                                <button v-on:click="soundsearch=''">Clear Search</button>
                                </p>
                                <div style="max-height:25em; overflow:scroll; background-color:rgba(255,255,255,0.4);">


                                    <div v-if="soundsearch">
                                        <table border="1">
                                            <tr>
                                                <th>File</th>
                                                <th>Add to Current</th>
                                                <th>Add to New</th>
                                            </tr>
                                            <tr v-for="i in soundsearchresults">
                                                <td v-bind:title="'Found in'+i[0]">{{i[1]}}</td>
                                                <td><button v-on:click="setSoundfile(currentcueid,(soundsearch.length ? '': soundfilesdir)+i[1])">Set</button></td>
                                                <td><button v-on:click="newCueFromSound(scenename,(soundsearch.length ? '': soundfilesdir)+i[1])">New</button></td>
                                            </tr>
                                        </table>
                                    </div>

                                    <div v-if="soundsearch==''">
                                        <h4>
                                            <a title="View in file manager" v-bind:href="'/settings/files'+encodeURI(soundfilesdir)" target="_blank">{{soundfilesdir}}</a>
                                        </h4>

                                        <ul>
                                            <li v-on:click="setSoundfileDir('')"><a>&ltTOP DIRECTORY&gt</a></li>
                                            <li v-if="soundfilesdir"  v-on:click="setSoundfileDir(((soundfilesdir.match(/(.*)[\/\\]/)[1]||'').match(/(.*)[\/\\]/)[1]||'')+'/')"><a>..</a></li>
                                            <li  v-on:click="setSoundfileDir(i[0])" v-for="i in soundfileslisting[0]"><a>{{i[1] || i[0]}}</a></li>
                                        </ul>

                                        <table border="1">
                                            <tr>
                                                <th>File</th>
                                                <th>Add to Current</th>
                                                <th>Add to New</th>
                                            </tr>
                                            <tr v-for="i in soundfileslisting[1]">
                                                <td>{{i}}</td>
                                                <td><button v-on:click="setSoundfile(currentcueid,soundfilesdir+i)">Set</button></td>
                                                <td><button v-on:click="newCueFromSound(scenename,soundfilesdir+i)">New</button></td>
                                            </tr>
                                        </table>
                                    </div>
                                </div>
                                <div class="scrollbox">
                                    <h5>Kaithem Sound Aliases</h5>
                                    <p class="help">So long as you plug the same device into the same port(on linux), it will be given the same device alias, although
                                        they will be different if JACK is used.</p>
                                    <table>
                                        <tr v-for="i of soundCards">
                                            <td>{{i}}</td>
                                            <td>
                                                <p class="buttonbar">
                                             <button v-on:click="setSoundOutput(currentcueid,i)">Set for Cue</button>
                                             <button v-on:click="testSoundCard(i,0,48000)">Test(48k)</button>
                                             <button v-on:click="testSoundCard(i,0,96000)">Test(96k)</button>
                                            <button v-on:click="testSoundCard(i,0,44100)">Test(44.1k)</button>
                                                </p>
                                        </tr>
                                    </table>
                                </div>
                        </div>



                        <div v-if="scenetab=='livingnight'">
                            <h3>LivingNight</h3>
                            <div style="display:inline-block;">
                                <p class="help">LivingNight is an algorithm for modifying random properties for better realism, to achieve effects like crickets
                                    quieting down when someone walks past. This is done with a global set of "attributes" like loudness, darkness, etc,
                                    that are affected by influences. Attributes can be any arbitrary work you choose. Cues can have any number of influences
                                    that increase or decrease these attributes.
                                </p>
                                <h4>Associations</h4>
                                <table border=1>
                                    <tr>
                                        <th title="Attributes reflect a condition of the virtual world that can be described by a number">Attribute</th>
                                        <th title="The parameter you want to control based on the attribute">Parameter</th>
                                        <th title="Positive values increase the parameter when that attribute is strong">Effect Level</th>
                                    </tr>

                                    <tr v-for="i in currentcue.associations">
                                        <td>i[0]</td>
                                        <td>i[1]</td>
                                        <td>i[2]</td>
                                        <tr>
                                </table>
                            </div>
                        </div>




                        <div v-if="scenetab=='cue'">
                            <h4 title="These properties belong to the selected cue and can vary between cues">Cue Properties</h4>
                            <div style="background-color:rgba(0,0,0,0.1)">
                            <h5>Basic</h5>
                            <div class="labelbox">
                        <label>Number:
                        <input type="number" title="Cue number" style="width:6em" v-on:input="setnumber(currentcueid,$event.target.value)"
                            min=0 step=0.1 v-model="currentcue.number">
                        </label>
                        
                           <label>Probability:
                        <input title="Probability this cue is selected in random selections. =expressions allowed" style="width:6em" v-on:input="setprobability(currentcueid,$event.target.value)"
                            v-model="currentcue.probability" placeholder="1">
                        </label>
                        
                                <label>Code:
                            <input title="Shortcut code used to quickly activate a cue" size="8" v-on:input="setshortcut(currentcueid,$event.target.value)"
                                v-model="currentcue.shortcut">
                        </label>
                                <label>Track:
                            <input type="checkbox" v-on:change="settrack(currentcueid,currentcue.track)" v-model="currentcue.track"
                                title="Track values from previous cue? If false, values not present are always transparent">
                        </label>

                                <label>Reentrant:<input title="If false, dissallow entering cue if it's already running" type="checkbox" v-on:change="setreentrant(currentcueid,currentcue.reentrant)" v-model="currentcue.reentrant"></label>

                        <label>Fadein:
                            <input type="number" v-on:input="setfadein(currentcueid,$event.target.value)" style="width:3em"
                                min=0 v-model="currentcue.fadein">{{scenemeta[scenename].bpm?"beats":"s"}}
                        </label>
                                <label>Length:
                            <input v-on:input="setlength(currentcueid,$event.target.value)" v-model="cuemeta[currentcueid].length"
                                style="width:6em" min=0></input>{{scenemeta[scenename].bpm?"beats":"s"}}
                        </label>
                                <label>Randomize Length:
                            <input type="number" v-on:input="setrandomize(currentcueid,$event.target.value)"
                                title="Randomize the cue length +- this amount" v-model="cuemeta[currentcueid].lengthRandomize"
                                style="width:4em" min=0 step=0.25></input>{{scenemeta[scenename].bpm?"beats":"s"}}
                        </label>
                                <div class="break"></div>
                                <h5 style="flex-basis:100%">Sound</h5>
                                <label v-if="showSoundControls">Soundfile:
                            <input placeholder="No sound file" v-model="currentcue.sound" title="File paths are resolved relative to any of the confg sound folders, searching all until a match is found"
                                style="width:32em;" v-on:change="setSoundfile(currentcueid,currentcue.sound)">
                        </label>
                                <label v-if="showSoundControls">Device:<a target="_blank" href="/settings/mixer">(mixer)</a>
                            <input title="set the output device" v-on:input="setSoundOutput(currentcueid,$event.target.value)"
                                v-model="cuemeta[currentcueid].soundOutput" placeholder="default"></input>
                        </label>

                                <label v-if="showSoundControls">Length From Sound:
                            <input type="checkbox" v-on:change="setrellen(currentcueid,currentcue.rel_len)" v-model="currentcue.rel_len"
                                title="If checked, the length parameter is interpreted as a delay after the sound cue ends.">
                        </label><br>

                                <h5 style="flex-basis:100%">Cue Advance</h5>
                                <label>Next Cue:
                            <combo-box v-model="cuemeta[currentcueid].next" v-on:change="setnext(currentcueid,cuemeta[currentcueid].next)" :options="useBlankDescriptions(scenecues[scenename],{'__random__':'','__shuffle__':'Avoid Recent','*':'Wildcard match'})"></combo-box>
                             </label>

                                <button v-on:click="gotonext(currentcueid)">
                        <img src="/zipstatic/img/icons/fugue.zip/book-open-next.png"></img>Edit Next</button>
                                <button title="If this cue's next does not exist, clone the current cue to be the next, and edit that cue" v-on:click="clonecue(scenename,currentcueid,currentcue.next)">
                        <img src="/zipstatic/img/icons/fugue.zip/document-copy.png"></img>Clone to Next</button>

                                <datalist id="cues_in_scene" v-if="Object.keys(scenecues[scenename]).length<50">
                                    <option v-for="i in Object.keys(scenecues[scenename]).sort()" v-bind:value="i">{{i}}</option>
                                </datalist>
                            </div>

                            </div>
                        </div>
                </div>

                   

                </div>
                 <div v-if="scenetab=='blend'">

                            <h4 title="These properties are fixed per-scene and don't change between cues">Global Scene Properties</h4>
    
                            <label v-if="showLightingControls">Default Alpha:
                        <input type="number" style="width:4em" max=1 step=0.01 min=0 v-on:input="setdalpha(scenename,parseFloat($event.target.value))"
                            v-model="editingScene.dalpha"></input>
                        </label>
                            <label v-if="showLightingControls">Blend Mode:
                            <select title="This setting controls blending multiple scenes together" v-on:input="setblend(scenename,$event.target.value)"
                                v-model="editingScene.blend">

                                <option title="Alpha blend with scenes below">normal</option>
                                <option title="Highest Takes Priority, only affect lights if the value is higher than the others">HTP</option>
                                <option title="Limit maximum level">inhibit</option>
                                <option title="Transparently monitor values">monitor</option>

                                <option v-for="i in ${[i for i in module.blendmodes.keys()]}">{{i}}</option>

                            </select>
                        </label>

                            <label>Priority:
                            <input type='number' min=0 max=100 style="width:3em" v-on:input="setpriority(scenename,parseFloat($event.target.value))"
                                v-model="editingScene.priority">
                        </label>
                            <label>BPM:
                            <input type='number' min=0 max=100 style="width:5em" v-on:input="setbpm(scenename,parseFloat($event.target.value))"
                                v-model="editingScene.bpm">
                        </label>
                            <button v-on:click="tap(scenename)">
                        <img src="/zipstatic/img/icons/fugue.zip/hand-finger.png"></img>Tap</button><br>


                            <label title="Check this box to make the scene active at startup">Active By Default:
                            <input type="checkbox" v-on:change="apiCommand(scenename,'setdefaultactive',$event.target.checked)"
                                v-model="editingScene.defaultActive"></input>
                        </label>

                            <label v-if="showLightingControls" title="Scenes inherit from previous scenes even if you jump directly to them">Backtrack:
                            <input type="checkbox" v-on:change="apiCommand(scenename,'setbacktrack', $event.target.checked)"
                                v-model="editingScene.backtrack"></input>
                        </label>

                            <label v-if="showSoundControls"> Sound Output: <input title="If not set by a cue, the global setting for the scene is used" v-on:input="setSceneSoundOutput(scenename,$event.target.value)"
                                v-model="editingScene.soundOutput" placeholder="default" list="soundcards"></input></label>
                            </br>

                        <label>
                        Crossfade for non-silent Sounds :
                        <input type="number" style="width:4em" max=1 step=0.01 min=0 v-on:input="setcrossfade(scenename,parseFloat($event.target.value))"
                            v-model="editingScene.crossfade"></input>s
                        </label>
        
   <label v-if="showAdvancedControls" >MQTT Server:
                            <input style="width:25em"  v-on:change="setmqtt(scenename,$event.target.value)"
                                v-model="editingScene.mqttServer"></input>
                        </label>

                           <label v-if="showAdvancedControls" title="Recieve note events from a MIDI input device">MIDI Source:
                            <input list="midiinputs" style="width:25em"  v-on:change="setmidi(scenename,$event.target.value)"
                                v-model="editingScene.midiSource"></input>
                        </label>

                           <label title="You can use this with __random__ to create a shuffle effect.">Default cue advance:
                            <input style="width:25em" list="nextcueoptions"  v-on:change="setdefaultnext(scenename,$event.target.value)"
                                v-model="editingScene.defaultNext" placeholder="Next cue in list"></input>
                        </label>


                            <hr v-if="editingScene.blend!='normal' & showLightingControls" style="border-style:solid;border-width:1px;border-color:grey;">
                            <p>{{editingScene.blendDesc}}</p>
                            <label v-for="(j,k) in editingScene.blendParams">{{j[0]}}:
                            <input type="number" style="width:5em" step=0.01 v-bind:title="j[2]" v-on:input="setblendparam(scenename,k,parseFloat($event.target.value))"
                                v-model="editingScene.blendArgs[k]"></input>

                        </label><br>

                            <label v-if="showAdvancedControls">Send event to this scene:
                                <input v-model="evtosend" v-on:keydown.enter="sendev" placeholder="Event Name" title="Event Name">

                                <input v-model="evval" v-on:keydown.enter="sendev" title="Event Value" placeholder="value">

                                <select v-model="evtypetosend">
                                    <option value="int">Integer</option>
                                    <option value="float">Real Number</option>
                                    <option value="str">Text</option>
                                </select>

                                <button v-on:click="sendev(scenename)">Send</button>
                     </label>
                            <div class="scrollbox" v-if="showSoundControls">
                                <h5>Kaithem Sound Aliases</h5>
                                <p class="help">So long as you plug the same device into the same port(on linux), it will be given the same device alias, although
                                    they will be different if JACK is used.</p>
                                <table>
                                    <tr v-for="i of soundCards">
                                        <td>{{i}}</td>
                                        <td> <button v-on:click="setSoundOutput(currentcueid,i)">Set for Cue</button></td>
                                        <td> <button v-on:click="setSceneSoundOutput(scenename,i)">Set as Scene Default</button></td>
                                        <td> <button v-on:click="testSoundCard(i,0,48000)">Test(48k)</button></td>
                                        <td> <button v-on:click="testSoundCard(i,0,96000)">Test(96k)</button></td>
                                        <td> <button v-on:click="testSoundCard(i,0,44100)">Test(44.1k)</button></td>

                                    </tr>
                                </table>
                            </div>

                        </div>
                <div v-if="scenecues[scenename][selectedCues[scenename]]==undefined || cuemeta[scenecues[scenename][selectedCues[scenename]]]==undefined">
                    Cue data not found...
                </div>

            </div>
            <div v-if="showevents" style="height:25em">
            </div>

        </div>


        <template id="cue-cd">
            <span>
    <meter v-bind:high=" (cue.length>30)?(scene.cuelen*(60/scene.bpm))-10:(scene.cuelen*(60/scene.bpm))" v-if="scene.active && cue && cue.length" min=0 v-bind:max="scene.cuelen*(60/scene.bpm)"
    v-bind:value="unixtime-scene.enteredCue"></meter><br>
    <span v-if="scene.active && cue && cue.length">
     Next cue in: {{((scene.cuelen*(60/scene.bpm))-(unixtime-scene.enteredCue))>-0.1 ? formatInterval((scene.cuelen*(60/scene.bpm))-(unixtime-scene.enteredCue)) : "NOW"}}
     <br>
     </span></span>
        </template>


        <template id="h-fader">
            <div class="hfader">
                <span>
            <b v-if="chinfo==undefined">{{i.ch}}</b>
            <b v-if="chinfo" v-bind:title="'Actual channel:'+i.u+':'+i.ch">{{i.ch}}</b>
        </span>

                <button v-if="showdelete" v-on:click="rmValFromCue(i.u,i.ch)"><img src="/zipstatic/img/icons/fugue.zip/minus-octagon-frame.png"></img>Remove</button>

                <span v-if="typeof(i.v)=='string'">
            <input v-bind:disabled="chinfo&&chinfo[2]=='fine'" 
                        v-if="!monitor"
                        v-on:input="setCueVal(currentcueid,i.u,i.ch,i.v)" v-model.lazy="i.v"
                        v-on:change="setCueValNolock(currentcueid,i.u,i.ch,$event.target.value)">

        </span>

                <span v-if="typeof(i.v)=='number'">
            <span v-if="i.v !== null">
                <input v-bind:disabled="chinfo&&chinfo[2]=='fine'" 
                    v-if="!monitor"
                    type="range" v-bind:step="(chinfo&&chinfo[2]=='fine')? 0.01:1"
                    :min="getValueRange(chinfo,i.v)[0]"
                    :max="getValueRange(chinfo,i.v)[1]"
                    v-on:input="setCueVal(currentcueid,i.u,i.ch,parseFloat($event.target.value))" v-model.number="i.v"
                    v-on:change="setCueValNolock(currentcueid,i.u,i.ch,parseFloat($event.target.value))">

                <meter v-if="monitor" type="range" max=255 v-bind:value="i.v"></meter>
            </span>

                <span v-if="i.v==null" class=grey>Released</span>



                <span v-if="!(chinfo&&chinfo[2]=='fine')" title="Double click to set exact value" v-on:dblclick="promptExactVal(currentcueid,i.u,i.ch)"
                    style="font-size:80%">{{Number(i.v).toPrecision(4)}}</span>
                    <span class=grey v-if="chinfo&&chinfo[2]=='fine'">auto</span>

                    <span v-if="chinfo&&(chinfo[2]=='red')" v-bind:style="{'background-color': 'rgb('+i.v+ ',0,0)' , 'border-color':'red'}" class="indicator"></span>
                    <span v-if="chinfo&&(chinfo[2]=='green')" v-bind:style="{'background-color': 'rgb(0,'+i.v+',0)' , 'border-color':'green'}"
                        class="indicator"></span>
                        <span v-if="chinfo&&(chinfo[2]=='blue')" v-bind:style="{'background-color': 'rgb(0,0,'+i.v+')'  , 'border-color':'blue'}"
                            class="indicator"></span>
                            <span v-if="chinfo&&chinfo[2]=='uv'" v-bind:style="{'background-color': 'rgb(i.v,0,'+i.v+')'  , 'border-color':'blue'}" class="indicator"></span>
                            <span v-if="chinfo&&chinfo[2]=='custom'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}" class="indicator"></span>
                            <span v-if="chinfo&&chinfo[2]=='intensity'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}" class="indicator"></span>
                            <span v-if="chinfo&&chinfo[2]=='white'" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}" class="indicator"></span>

                            <span v-if="chinfo==undefined" v-bind:style="{'background-color': 'rgb(' +i.v+ ','+i.v+','+i.v+')'}" class="indicator"></span>


                            <span v-if="chinfo&&chinfo[2]=='custom'"><br>
                <select :value="getValueRange(chinfo,i.v)[2]" v-on:change="setCueValNolock(currentcueid,i.u,i.ch,mapvaluerange(i.v, chinfo, $event.target.value))"> 
                    <option v-for="i of chinfo.slice(3)" :value="i[2]">{{i[2]}}({{i[0]}} to {{i[1]}})</option>
                </select>
            </span>
                            </span>
            </div>
        </template>


        <div>

            ${module.board.link.render('api_link')}

            <script src="/static/js/src-min-noconflict/ace.js"></script>
            <script src="/static/js/jquery3.js"></script>

            <script>
                const VueAceEditor = {
            //  simplified model handling using `value` prop and `input` event for $emit 
            props:['value','id','options'],

            //  add dynmic class and id (if not set) based on component tag
            template:`
                <div :id="id ? id: $options._componentTag +'-'+ _uid" 
                    :class="$options._componentTag">
                    <slot></slot>
                </div>
            `,

            watch:{
                value(){
                    //This is the forward 
                    //  update value on external model changes
                    if(this.oldValue !== this.value){ 
                        this.oldValue=this.value;
                        if(this.ivalue !== this.value){
                            if(!this.locked)
                            {
                                this.editor.setValue(this.value, 1);
                                return;
                            }
                        }
                    }
                    //We don't accept the change, so we emit an event to change it back
                    this.$emit('input', this.ivalue);
                }
            },
        
            mounted(){
                //  editor
                this.editor = window.ace.edit(this.$el.id);
                
                //  deprecation fix
                this.editor.$blockScrolling = Infinity;
                this.locked =0     

                //  ignore doctype warnings
                const session = this.editor.getSession();
                session.on("changeAnnotation", () => {
                    const a = session.getAnnotations();
                    const b = a.slice(0).filter( (item) => item.text.indexOf('DOC') == -1 );
                    if(a.length > b.length) session.setAnnotations(b);
                });

                //  editor options 
                //  https://github.com/ajaxorg/ace/wiki/Configuring-Ace
                this.options = this.options || {};
                
                //  opinionated option defaults
                this.options.maxLines = this.options.maxLines || Infinity;
                this.options.printMargin = this.options.printMargin || false;      
                this.options.highlightActiveLine = this.options.highlightActiveLine || false;

                //  hide cursor 
                if(this.options.cursor === 'none' || this.options.cursor === false){
                    this.editor.renderer.$cursorLayer.element.style.display = 'none';
                    delete this.options.cursor; 
                }

                //  add missing mode and theme paths 
                if(this.options.mode && this.options.mode.indexOf('ace/mode/')===-1) {
                    this.options.mode = 'ace/mode/'+this.options.mode;
                }
                if(this.options.theme && this.options.theme.indexOf('ace/theme/')===-1) {
                    this.options.theme = 'ace/theme/'+this.options.theme;
                }
                this.editor.setOptions(this.options);
                
                
                //  set model value 
                //  if no model value found – use slot content
                if(!this.value || this.value === ''){
                    this.$emit('input', this.editor.getValue());
                    this.$emit('change', this.editor.getValue());
                    this.ivalue = this.ivalue = this.oldValue = this.editor.getValue();
                } else {
                    this.editor.setValue(this.value, -1);
                    this.ivalue = this.oldValue = this.value;
                }        
                
                //  editor value changes   
                this.editor.on('change', () => {
                    //  oldValue set to prevent internal updates
                    this.ivalue = this.oldValue = this.editor.getValue();
                });
                //  editor value changes   
                this.editor.on('input', () => {
                    //  oldValue set to prevent internal updates
                    this.locked =1;
                    this.ivalue = this.oldValue = this.editor.getValue();
                    this.$emit('input', this.ivalue);
                });
                 //  editor value changes   
                this.editor.on('blur', () => {
                    this.$emit('change', this.ivalue);
                    this.locked =0;
                });

            },
            methods: { editor(){ return this.editor } }
        };
            </script>

            <script>
                formatInterval = function(seconds)
        {
            var hours = Math.floor(seconds / 3600);
            var minutes = Math.floor((seconds - (hours * 3600)) /
                60);
            var seconds = seconds - (hours * 3600) - (minutes * 60);
            var tenths = Math.floor((seconds - Math.floor(seconds)) *
                10);
            seconds = Math.floor(seconds);

            var time = "";

            time = hours + "h " + minutes + "m " + seconds + "." +
                tenths + "s"
            return time;
        }


        Vue.component('cue-countdown',
        {
            template: '#cue-cd',
            props: ['unixtime', 'cue', 'scene'],
            data: function()
            {
                return ({ 'formatInterval': formatInterval })
            }
        })
        
        getValueRange = function(d, v)
            {
                //Given a channel info list structure thing and a value, return the [min,max,name] of the range
                //that the value is in
                if (d == undefined) { return ([0, 255, "Unknown"]) }
                var c = 0
                for (i of d)
                {
                    if (c > 2)
                    {
                        if (i[1] >= v)
                        {
                            //Better to return Unknown then bad data
                            if (i.length == 3)
                            {
                                return (i)
                            }
                        }
                    }
                    c += 1
                }
                return ([0, 255, "Unknown"])
            }
        

        hfaderdata =
        {
           'promptExactVal': function(cue, u, v)
            {
                var x = prompt("Enter new value for scene")

                if (x != null)
                {

                        this.setCueValNolock(cue, u, v, x);
                }
            },
            'setCueVal': function(sc, u, ch, val)
            {
                appData.lockedFaders[sc+":"+u+":"+ch]=true;
                api_link.send(['scv', sc, u, ch, val]);
            },
            'setCueValNolock': function(sc, u, ch, val)
            {
                api_link.send(['scv', sc, u, ch, val]);
            },
            'unlockCueValFader': function(sc, u, ch)
            {
                delete appData.lockedFaders[sc+":"+u+":"+ch];
            },
            'getValueRange':getValueRange,
            
            'rmValFromCue': function(universe,ch)
            {
                api_link.send(['scv', appData.scenecues[appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    universe,
                    ch,
                    null
                ])
                Vue.delete(appData.cuevals[appData.selectedCues[appData
                    .scenename]][appData.newcueu],
                    ch)
                Vue.delete(appData.cuevals[appData.selectedCues[appData
                    .scenename]][appData.newcueu],
                    ch)
            },
        }

        Vue.component('h-fader',
        {
            template: '#h-fader',
            //I is a data object having u,ch, and v, the universe channel and value.
            //Chinfo is the channel info list from the fixtues that you get with chnamelookup
            props: ['i', 'chinfo','monitor','currentcueid','showdelete'],
            data: function()
            {
                return (hfaderdata)
            }
        })        
        


        //# sourceURL=appcode.js 
        appData = {
            //Ace code editor
                htmloptions:{
                mode:'html',
                theme: 'tomorrow',
                fontSize: 11,
                fontFamily: 'monospace',
                highlightActiveLine: false,
                highlightGutterLine: false              
              }, 
              cssoptions:{
                mode:'css',
                theme: 'tomorrow',
                fontSize: 11,
                fontFamily: 'monospace',
                highlightActiveLine: false,
                highlightGutterLine: false              
              },                
              jsoptions:{
                mode:'javascript',
                theme: 'tomorrow',
                fontSize: 11,
                fontFamily: 'monospace',
                highlightActiveLine: false,
                highlightGutterLine: false              
              },  
               mdooptions:{
                mode:'markdown',
                theme: 'tomorrow',
                fontSize: 11,
                fontFamily: 'monospace',
                highlightActiveLine: false,
                highlightGutterLine: false              
              },  


            'eventlogautoscroll': true,
            //https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss
            'formatInterval': formatInterval,
            'console': console,
            'sc_code': "",
            'unixtime': 0,
            'serports': [],
            'bindingsListTest':[],
            'keyboardJS':keyboardJS,
            //Code view for the fixture assignments
            'fixturescode': '',
            //Index by name
            'fixtureAssignments': {},
            'newfixname':'',
            'newfixtype':'',
            'newfixaddr':'',
            'newfixuniverse':'',
            //Fixture error info str
            'ferrs': '',
            'fixtures': '',
            'evfilt': '',
            'newcueu': '',
            'newcuevnumber':'',
            'newscenename':'',
            'specialvars':[
                ["_","Output of the previous action"]
            ],


            //The code in the fixture edit as code box
            'fixturecode':'',
            'evlog': [
            ],
            'soundCards': ${json.dumps([i for i in kaithem.sound.outputs()])},
            
            //What universe if any to show the full settings page for
            'universeFullSettings': false,
        
            'showfixtureassg': false,
            'fixtureassg': '',
            'showsoundoptions': false,
            'showevents': false,

            'example_events': [['now', "Run when script loads"],['cue.exit','When exiting a cue'],['cue.enter','When entering a cue'], 
                ['keydown.a',"When a lowercase A is pressed in the Send Events mode"], ["=log(90)", 'Example polled expression. =Expressions are polled every few seconds or on certain triggers.'],
                ['@january 5th', "Run every jan 5 at midnight"], ['@every day at 2am US/Pacific', 'Time zones supported'], ['@every 10 seconds', 'Simple repeating trigger'],
                 ["=isNight()", 'Run if it is nighttime(polled)'], ["=isNight()", 'Run if it is nighttime(polled)'],
                ["=isDark()", 'Run if it is civil twilight'], ["=tv('TagPointName')", 'Run when tag point becomes nonzero(instant, poll is triggered on change)'], ["script.poll", 'Run every fast(~24Hz) polling cycle of the script, not the same as =expressions']],
            'showimportexport':false,
            'evtosend': '',
            'evtypetosend': 'float',
            'evval': '',
            'savedThisSession': false,
            'useBlankDescriptions': useBlankDescriptions,
            'saveToDisk': function()
            {
                if (this.savedThisSession==false)
                {
                    var x =confirm("This saves directly to disk, overwriting the previous default. This message only shows the first save.")
                    if(!x)
                    {
                        return
                    }
                    this.savedThisSession=true;
                }
                api_link.send(['saveScenes'])
            },
            
            'saveSetup': function()
            {
               
                api_link.send(['saveSetup'])
            },
             'saveLibrary': function()
            {
               
                api_link.send(['saveLibrary'])
            },
            'sendev': function(where)

            {
                api_link.send(['event', appData.evtosend, appData.evval, appData.evtypetosend,where])
            },
            

            //For the raw cue data edit thing
            'cuedatafield': "", 
            'refreshcuedata':function()
            {
                try{
                scene = this.scenename
                cueid = this.scenecues[scene][this.selectedCues[scene]]

                this.cuedatafield = jsyaml.safeDump(this
                .formatCueVals(
                    this.cuevals[cueid]));
                }
                catch
                    {
                        
                    }
            },

            'del': Vue.delete,
            'refreshPorts': function()
            {
                api_link.send(['getserports'])
            },
            'pushSettings': function()
            {
                api_link.send(['setconfuniverses', appData.configuredUniverses])
            },

            'showDMXSetup': false,
            'showsceneoptions': false,
            'showsoundmixer': false,
            'showtags': false,
            'scenetab': 'cue',
            'configuredUniverses':
            {
                'blah': { 'type': 'enttec', 'interface': 'xyz' }
            },
            'gamepad': false,
            'newuniversename': "",
            'fixtureClasses': { 'dfjlkdjf': [] },
            'selectedFixtureClass': '',
            'showFixtureSetup': false,
            //The selected dir and [[folders][files]] in that dir, for the
            //sound file browser
            'soundfilesdir': '',
            'soundfileslisting': [
                [],
                []
            ],
            'setSoundfileDir': function(i)
            {
                
                if(! ((i=='')| (i[0]=='/') ))
                {
                    appData.soundfilesdir += i;
                }
                else
                {
                    appData.soundfilesdir = i;
                }
                appData.soundfileslisting = [
                    [],
                    []
                ]
                api_link.send(['listsoundfolder', i])
            },
            'setSoundOutput': function(cueid, i)
            {

                api_link.send(['setcuesoundoutput', cueid, i])
            },
            'setSoundfile': function(cueid, i)
            {

                api_link.send(['setcuesound', cueid, i])
            },
               'setSceneSoundOutput': function(cueid, i)
            {

                api_link.send(['setscenesoundout', cueid, i])
            },
         
            'newCueFromSound': function(sc, i)
            {

                api_link.send(['newFromSound', sc, i])
            },
            'chTypeChanged': function(i)
            {
                if (appData.fixtureClasses[appData.selectedFixtureClass]
                    [i][1] == 'fine')
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 2, i - 1)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 3, undefined)
                }
                else
                {
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 2, null)
                    Vue.set(appData.fixtureClasses[appData.selectedFixtureClass]
                        [i], 3, null)

                }
                appData.pushfixture(i)
            },

            'setSceneNotes': function(sc, i)
            {

                api_link.send(['setNotes', sc, i])
            },
            'getValueRange': getValueRange,
            //Returns new value mapped into the range when user clicks to change the range of a custom val
            //Given current val, new range info and old range info
            'mapvaluerange': function(oldv, d, newrange)
            {
                for (i of d)
                {
                    if (i[2] == newrange)
                    {
                        var newd = i
                        break;
                    }
                }
                var d = appData.getValueRange(d, oldv)

                try
                {
                    var asfraction = (oldv - d[0]) / ((d[1] - d[0]) +
                        1)
                    return Math.round(asfraction * (newd[1] - newd[
                        0] + 1) + newd[0])
                }
                catch (e)
                {
                    return newd[0]
                }
            },

            'saveFixtureTypeFromCode': function(fixture, code)
            {
                try{
                    appData.fixtureClasses[fixture]=JSON.parse(code)
                }
                catch
                {
                    alert("Could not set JSON data. Syntax error?")
                }
                appData.pushfixture(fixture)

            },

            'pushfixture': function(i)
            {
                api_link.send(['setfixtureclass', i, appData.fixtureClasses[
                    i]])
            },
            'pushfixturescode': function()
            {
                api_link.send(['setfixturesfromcode', appData.fixturescode])
            },

            'setFixtureAssignment': function(i,v)
            {
                api_link.send(['setFixtureAssignment',i,v])
            },

            'rmFixtureAssignment': function(i)
            {
                api_link.send(['rmFixtureAssignment',i])
            },


            'addFixtureAssignment': function(name, t, univ,addr)
            {
                if(!name)
                {
                    return;
                }
                var d={
                    'name':name,
                    'type':t,
                    'universe':univ,
                    'addr':addr
                }

                api_link.send(['setFixtureAssignment',name,d])

            },
            'getfixtureassg': function()
            {
                api_link.send(['getfixtureassg'])
            },

            'getChannelCompletions': function(u)
            {
                var x =appData.configuredUniverses[u];
                if (x)
                {
                    return useBlankDescriptions(x.channelConfig);
                }
            },
            'showhidefixtures': function()
            {
                appData.showFixtureSetup = !  appData.showFixtureSetup
                appData.getfixtureclasses()
                appData.selectedFixtureClass = ''
            },
            'showhidefixtureassignments': function()
            {
                appData.getfixtureclasses()
                appData.showfixtureassg = ! appData.showfixtureassg;
                api_link.send(['getfixtureassg']);
            },
            'getfixtureclasses': function()
            {
                api_link.send(['getfixtureclasses'])
            },
            'getfixtureclass': function(i)
            {
                if(i=='')
                {
                    return;
                }
                //Reset the textbox when it changes
                appData.fixturecode = '';
                api_link.send(['getfixtureclass', i])
            },

            'addfixturetype': function()
            {
                x = prompt("New Fixture Type Name:",appData.selectedFixtureType)
                if (x)
                {
                    Vue.set(appData.fixtureClasses, x, [])
                    appData.selectedFixtureType = x
                    api_link.send(['setfixtureclass', x, appData.fixtureClasses[x]])
                    api_link.send(['getfixtureclass', x])
                }
            },
            'delfixturetype': function()
            {
                x = confirm("Really delete?")
                if (x)
                {
                    Vue.delete(appData.fixtureClasses, appData.selectedFixtureType)
                    api_link.send(['rmfixtureclass', appData.selectedFixtureType])
                    appData.selectedFixtureType='';
                }
            },
            'dictView': function(dict, sorts)
            {
                //Given a dict  and a list of sort keys sorts,
                //return a list of [key,value] pairs sorted by the sort 
                //keys. Earlier sort keys take precendence.

                //Keys starting with ! are interpreted as meanng to sort in descending order

                var o = []
                Object.keys(dict).forEach(
                    function(key, index)
                    {
                        o.push([key, dict[key]])
                    })

                var l = []
                for (var i of sorts)
                {
                    //Convert to (reverse, string) tuple where reverse is -1 if str started with an exclamation point
                    //Get rid of the fist char if so
                    l.push([
                        i[0] == '!' ? -1 : 1,
                        i[0] == "!" ? i.slice(1) : i
                    ])
                }

                o.sort(function(a, b)
                {
                    //For each of the possible soft keys, check if they
                    //are different. If so, compare and possible reverse the ouptut

                    var d = a[1]
                    var d2 = b[1]
                    for (i of l)
                    {
                        var key = i[1]
                        var rev = i[0]
                        if (!(d[key] == d2[key]))
                        {
                            return (d[key] > d2[key] ? 1 :-1) * rev
                        }

                    }
                    return 0
                });
                return (o)
            },

            'formatScenes': function()
            {
                if (!appData.showAll)
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', '!started', 'name'
                    ]).filter(
                        function(x)
                        {
                            return (x[1].name && x[1].name.includes(
                                appData.scenefilter))
                        }).filter(
                        function(x)
                        {
                            return x[1].active
                        });
                }
                else
                {
                    return appData.dictView(appData.scenemeta, [
                        '!priority', 'name'
                    ]).filter(function(x)
                    {
                        return ((!x[1].ext) && ((x[1].name &&
                            x[
                                1].name.includes(
                                appData.scenefilter
                            ))))
                    })
                }

            },
            'cueNamesBySceneName':function()
            {
                var d ={}
                for (i in appData.scenemeta)
                {
                    d[appData.scenemeta[i].name]=[]

                    for (j in appData.scenecues[i])
                    {
                        d[appData.scenemeta[i].name].push(j)
                    }
                }
                return d;
            },
            'formatCues': function(filt)
            {
                z = {}
                //list cue objects
                for (i in appData.scenecues[appData.scenename])
                {
                    m = appData.cuemeta[appData.scenecues[appData.scenename]
                        [i]]
                    if (m !== undefined)
                    {
                        if ((!filt) | i.includes(this.cuefilter))
                        {
                            z[i] = m
                        }
                    }
                }
                if(!filt)
                {
                    appData.formattedCues = appData.dictView(z, ['number'])
                    return appData.formattedCues
                }
                else
                {
                    return appData.dictView(z, ['number'])
                }
            },

            'formatCueVals': function(c)
            {
                //Return a simplified version of the data in cuevals
                //Meant for direct display
                op = {}
                for( i in c)
                {
                    op[i]={}
                    for (j in c[i])
                    {
                        op[i][j]=c[i][j].v
                    }
                }
                return op
            },

    

            'toggleTransparent': function(cue, u, c, v)
            {
                if (v != null)
                {
                    appData.setCueValNolock(cue, u, c, null)
                }
                else
                {
                    appData.setCueValNolock(cie, u, c, null)
                }
            },
            'promptRename' (s)
            {
                var x = prompt(
                    "Enter new name for scene(May break existing references to scene)"
                )

                if (x != null)
                {

                    api_link.send(['setscenename', s, x])

                }

            },
            //If false, only show active scenes
            'showAll': true,
            'deleteUniverse': function(u)
            {
                console.log(u)
                Vue.delete(appData.configuredUniverses, u)
            },
            //Filter which scenes are shown in the list
            'scenefilter': '',
            'cuefilter': '',
            'soundsearch':'',
            'soundsearchresults':[],
            'currentBindingBank': 'default',
            'localStorage': localStorage,
            'keybindscript': localStorage.getItem("keybind-script"),
            'keybindmode': 'edit',
            'showAddChannels':false,
            'showLightingControls': true,
            'showAdvancedControls': true,
            'showSoundControls': true,
            //Keep track of what timers are running in a scene
            'scenetimers':{},
            //Formatted for display
            'cuevals': {},

            'fuzzyIncludes'(s, search)
            {
                for ( i of search.toLowerCase().split(" "))
                {
                    if (!s.toLowerCase().includes(i))
                    {
                        return 0;
                    }
                }
                return 1;
            },
            'setCueInheritRules': function(c,r)
            {
                api_link.send(['setCueInheritRules',c,r])
            },

            
            'setCueRules': function(c,r)
            {
                api_link.send(['setCueRules',c,r])
            },

            'doSoundSearch': function(s)
            {
                api_link.send( ["searchsounds", s]  )
            },
            //l must be a universe dict
            'groupByFixture': function(l)
            {
                //Output buf
                var o = [];
                //Fill up this buf, then append to o when the group changes
                var c = []
                var x = null;

                for (n in l)
                {
                    var i = l[n]
                    if (appData.chnamelookup(i.u, i.ch))
                    {
                        var f = appData.channelNames[i.u][i.ch][0]
                    }
                    else
                    {
                        var f = i.ch;
                    }

                    if (f == x)
                    {

                        c.push(i)
                    }
                    else
                    {
                        if (x)
                        {
                            o.push(c)
                        }
                        x = f
                        c = []
                        c.push(i)
                    }

                }
                if (c)
                {
                    o.push(c)
                }
                return (o)

            },
            //Current per scene alpha channel
            'alphas': {},
            //Used only for autocompletion, it's a list of all known tracks that we've seen so far.
            'knownTracks': {},
            'scenemeta': {},
            'scenename': null,
            'editingScene': null,
            'running_scenes': {},
            'universes': {},
            'allScenes': [],
            'cues': {},
            'newcuename': '',
            'cuemeta': {},
            'availableCommands': {},
            'selectedCues': {},

            //go from cue name to cue id
            //scenecues[sceneuuid][cuename]=cueid
            'scenecues': {},
            'formattedCues': [],
            //Indexed by universe then channel number
            'channelNames': {},
            //same info as scenevals, indexed hierarchally, as [universe][channel]
            //Actual objs are shared too so changing one obj change in in the other.

            //We must track faders the user is actively touching so new data doesn't
            //Annoy you jumping them around
            'lockedFaders': {},

            'recomputeformattedCues':function()
            {
                appData.formatCues(0)

            },
            'chnamelookup': function(u, c)
            {
                if (appData.channelNames[u] == undefined)
                {
                    return undefined
                }

                return appData.channelNames[u][c]
            },
            "getcueid": function(sceneid, cuename)
            {
                return (this.scenecues[sceneid][cuename])
            },
            'setCueVal': function(sc, u, ch, val)
            {
                this.lockedFaders[sc+":"+u+":"+ch]=true;
                api_link.send(['scv', sc, u, ch, val]);
            },
            'setCueValNolock': function(sc, u, ch, val)
            {
                api_link.send(['scv', sc, u, ch, val]);
            },
            'unlockCueValFader': function(sc, u, ch)
            {
                delete this.lockedFaders[sc+":"+u+":"+ch];
            },

            'selectcue': function(sc, cue)
            {
                this.selectedCues[sc] = cue
                this.getcuedata(this.scenecues[sc][cue])
                appData.refreshcuedata()

            },
            'getallcuemeta': function(sn)
            {
                api_link.send(['getallcuemeta', sn]);

            },
            'cond_getcuemeta': function(b)
            {
                if (b)
                {
                    api_link.send(['getallcuemeta', this.scenename]);
                }
            },
            'selectscene': function(sc, sn)
            {
                this.getcuedata(this.scenecues[sn][this.selectedCues[
                    sc] || 'default'])
                this.editingScene = sc;
                this.scenename = sn;
                api_link.send(['gsd', sn]);
                api_link.send(['getallcuemeta', sn]);
                appData.refreshcuedata()
                appData.recomputeformattedCues();


            },
            'delscene': function(sc)
            {
                var r = confirm("Really delete scene?");
                if (r == true)
                {
                    api_link.send(['del', sc]);
                }
            },

            'go': function(sc)
            {

                api_link.send(['go', sc]);
            },

            'goByName': function(sn)
            {

                api_link.send(['gobyname', sn]);
            },

            'toggleByName': function(sn)
            {

                api_link.send(['togglebyname', sn]);
            },

            'stopByName': function(sn)
            {

                api_link.send(['stopbyname', sn]);
            },

            'shortcut': function(sc)
            {
                api_link.send(['shortcut', appData.sc_code]);
                appData.sc_code = ''

            },

            'stop': function(sc, sn)
            {
                if (appData.scenemeta[sc].ext)
                {
                    var x = confirm(
                        "Really stop external scene? \nIt will dissapear from the scene listing because it is not owned by this light board.\n You may need to re-save an event to start it again."
                    )
                }
                else
                {
                   var x = confirm(
                        "Really stop scene? The cue and all variables will be reset."
                    )
                }
                if (x)
                {
                    api_link.send(['stop', sc]);
                }
            },


            'setalpha': function(sc, v)
            {
                appData.lockedFaders[sc]=true;
                api_link.send(['setalpha', sc, v]);
                appData.alphas[sc] = v
            },
            'unlockAlpha':function(sc)
            {
                delete appData.lockedFaders[sc];
            },


            'setfade': function(sc, v)
            {

                api_link.send(['setfade', sc, v]);
            },
            'nextcue': function(sc)
            {
                api_link.send(['nextcue', sc]);
            },

            'addcue': function(sc, v)
            {
                api_link.send(['addcue', sc, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                    appData.recomputeformattedCues();
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)
            },

            'clonecue': function(sc, cue, v)
            {
                api_link.send(['clonecue', cue, v]);
                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[sc][v] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    Vue.set(appData.scenecues[sc], v, undefined);
                    appData.recomputeformattedCues();
                };
                setTimeout(function()
                {
                    Vue.set(appData.selectedCues,
                        sc, v)
                }, 70)

            },
            'gotonext': function(currentcueid)
            {
                nextcue = appData.cuemeta[currentcueid].next

                cue = nextcue || (appData.cuemeta[currentcueid].defaultnext)
                if (!cue)
                {
                    return
                }
                api_link.send(['addcue', appData.scenename, nextcue]);
                api_link.send(['getcuedata', cue]);

                //There's a difference between "not there" undefined and actually set to undefined....
                if (appData.scenecues[cue] == undefined)
                {
                    //Placeholder so we can at least show a no cue found message till it arrives
                    set(appData.scenecues[appData.scenename], cue,
                        undefined);
                }
                setTimeout(function()
                    {
                        Vue.set(appData.selectedCues,
                            appData.scenename, cue)
                    },
                    30)
            },
            'rmcue': function(cue)
            {
                appData.selectedCues[appData.scenename] = 'default'
                api_link.send(['rmcue', cue]);
            },
            'jumptocue': function(cue)
            {
                api_link.send(['jumptocue', cue]);
            },
            'getcuedata': function(c)
            {

                api_link.send(['getcuedata', c]);
            },
            'getcuemeta': function(c)
            {

                api_link.send(['getcuemeta', c]);
            },
            'setnext': function(sc, cue, v)
            {
                api_link.send(['setnext', sc, cue, v]);
            },

            'setprobability': function(sc, cue, v)
            {
                api_link.send(['setprobability', sc, cue, v]);
            },
            'setcuevaldata': function(cue, v)
            {
                api_link.send(['setcuevaldata',cue, jsyaml.safeLoad(v)]);
            },


            'promptsetnumber': function(cue)
            {
                api_link.send(['setnumber', cue, Number(prompt(
                    "Enter new number for this cue:"))]);
            },

            'setnumber': function(cue, v)
            {
                api_link.send(['setnumber', cue, v]);
            },

            'setfadein': function(cue, v)
            {
                api_link.send(['setfadein', cue, v]);
            },

            'setSoundFadeOut': function(cue, v)
            {
                api_link.send(['setSoundFadeOut', cue, v]);
            },

            'setSoundFadeIn': function(cue, v)
            {
                api_link.send(['setSoundFadeIn', cue, v]);
            },

            'setCueVolume': function(cue, v)
            {
                api_link.send(['setCueVolume', cue, v]);
            },
            'setCueLoops': function(cue, v)
            {
                api_link.send(['setCueLoops', cue, v]);
            },
            'setreentrant': function(cue, v)
            {
                api_link.send(['setreentrant', cue, v]);
            },
            'settrack': function(cue, v)
            {
                api_link.send(['settrack', cue, v]);
            },
            'setrellen': function(cue, v)
            {
                api_link.send(['setrellen', cue, v]);
            },
            'setblend': function(sc, v)
            {
                api_link.send(['setblend', sc, v]);
            },
            'setblendparam': function(sc, k, v)
            {

                api_link.send(['setblendarg', sc, k, v]);
            },
            
            //Only for things of the form command/property, object/operand, argument/value
            'apiCommand': function(sc, p,v)
            {

                api_link.send([p, sc, v]);
            },

            'setlength': function(sc, v)
            {

                api_link.send(['setlength', sc, v]);
            },
            'setrandomize': function(sc, v)
            {

                api_link.send(['setrandomize', sc, v]);
            },

            'setdalpha': function(sc, v)
            {

                appData.scenemeta[sc].alpha = v;
                api_link.send(['setdalpha', sc, v]);
            },

    
            'setcrossfade': function(sc, v)
            {

                appData.scenemeta[sc].crossfade = v;
                api_link.send(['setcrossfade', sc, v]);
            },
            'setmqtt': function(sc, v)
            {

                appData.scenemeta[sc].mqttServer = v;
                api_link.send(['setMqttServer', sc, v]);
            },
            'setmidi': function(sc, v)
            {

                appData.scenemeta[sc].midiSource = v;
                api_link.send(['setMidiSource', sc, v]);
            },

            'setdefaultnext': function(sc, v)
            {

                appData.scenemeta[sc].defaultNext = v;
                api_link.send(['setDefaultNext', sc, v]);
            },
            'setpriority': function(sc, v)
            {
                api_link.send(['setpriority', sc, v]);
            },
            'setbpm': function(sc, v)
            {
                api_link.send(['setbpm', sc, v]);
            },
            'tap': function(sc)
            {
                api_link.send(['tap', sc, api_link.now() / 1000]);
            },
           'testSoundCard': function(sc,c)
            {
                api_link.send(['testSoundCard', sc,c]);
            },


            'addScene': function()
            {
                api_link.send(['addscene', appData.newscenename]);
            },

            'addMonitorScene': function()
            {
                api_link.send(['addmonitor', appData.newscenename]);
            },


            'addThisFixToCurrentCue': function(fix)
            {
                api_link.send(['addcuef', appData.scenecues[
                        appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    fix
                ]);

            },
            'rmFixCue': function(cue,fix)
            {
                api_link.send(['rmcuef', cue,fix]);

            },

            'addValToCue': function()
            {
                if (!appData.newcueu)
                {
                    return
                }
                api_link.send(['addcueval', appData.scenecues[
                        appData.scenename]
                    [appData.selectedCues[appData.scenename]],
                    appData.newcueu, appData.newcuevnumber
                ]);
                if(parseInt( appData.newcuevnumber) != NaN)
                {
                    appData.newcuevnumber = parseInt(appData.newcuevnumber)+1
                }

            },

            'sortscenes': function()
            {

                appData.allScenes.sort(function(a, b)
                {
                    return a[3] - b[3]
                })
            },
            'editMode': function()
            {
                keyboardJS.reset();
                appData.keybindmode = "edit";
            },
            'runMode': function()
            {
                rebind(appData.keybindscript);
                appData.keybindmode = "run";
            },
            //https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
            'isNumeric': function(input)
            {
                var RE = /^-{0,1}\d*\.{0,1}\d+$/;
                return (RE.test(input));
            }

        }


        var sceneslist = new Vue(
        {
            el: '#app',
            data: appData,
            components: {
                "combo-box": httpVueLoader('/static/vue/ComboBox.vue'),
                "script-editor": httpVueLoader('ui/ScriptEditor.vue'),
                'vue-ace-editor': VueAceEditor

                },
            computed:
            {
                "currentcue": function()
                {
                    return (this.cuemeta[this.scenecues[this.scenename]
                        [this.selectedCues[this.scenename]]
                    ])
                },
                "currentcueid": function()
                {
                    return (this.scenecues[this.scenename][this
                        .selectedCues[
                            this.scenename]
                    ])
                }

            }
        })

        function f(v)
        {
            c = v[0]

            if (c=='scenetimers')
            {
                appData.scenemeta[v[1]].timers=v[2]
            }

            if (c == "scenemeta")
            {
                if (v[2].cue)
                {
                    if (appData.cuemeta[v[2].cue] == undefined)
                    {
                        appData.getcuemeta(v[2].cue)
                    }
                }

                if(v[2].alpha!=undefined)
                {
                    if (!appData.lockedFaders[v[1]])
                    {
                        Vue.set(appData.alphas, v[1], v[2].alpha);
                    }
                }
                
                //Just update existing data if we can
                if(appData.scenemeta[v[1]])
                {
                    Object.assign(appData.scenemeta[v[1]], v[2])
                }
                else
                {
                    var meta = v[2];
                    set(appData.scenemeta, v[1], meta);
                }
                
                if (appData.selectedCues[v[1]] == undefined)
                {
                    Vue.set(appData.selectedCues, v[1], 'default')
                }
                //Make an empty list of cues as a placeholder till the real data arrives
                if (appData.scenecues[v[1]] == undefined)
                {
                    Vue.set(appData.scenecues, v[1], {});
                };
            }

            if (c == "cuemeta")
            {
                //Make an empty list of cues if it's not there yet
                if (appData.scenecues[v[2].scene] == undefined)
                {
                    Vue.set(appData.scenecues, v[2].scene, {});
                };
                Vue.set(appData.scenecues[v[2].scene], v[2].name, v[1]);
                
                
                //Make an empty list of cues as a placeholder till the real data arrives
                if (appData.cuemeta[v[1]] == undefined)
                {
                    Vue.set(appData.cuemeta, v[1], {});
                };
                set(appData.cuemeta, v[1], v[2]);
                appData.recomputeformattedCues();

            }

            if (c == "event")
            {
               
               appData.evlog.push(v[1])
               if (appData.evlog.length > 250)
               {
                   appData.evlog = appData.evlog.slice(-250)
               }

               if (v[1][0].includes("error")){
                   appData.showevents= true;
               }
               
               if(appData.showevents)
               {
                   if(appData.eventlogautoscroll)
                   {
                       var d = document.getElementById('eventlogbox');
                        var isscrolled =d.scrollTop+d.clientHeight+35 >= d.scrollHeight;

                        if(isscrolled)
                            {
                           setTimeout(function(){
                            if(d){
                         
                                    d.scrollTop = d.scrollHeight;
    
                        } 
                       },150)
                       }

                   }              
                    
               }
                var element = document.getElementById('eventlogbox_scene');

                if(element)
                {
                    setTimeout(function(){
                        if(element)
                        {
                    element.scrollTop = element.scrollHeight-element.clientHeight;
                        }
                    },150)
                }
            }
            if (c == "serports")
            {
                appData.serports = v[1]
            }
            if (c == 'confuniverses')
            {
                appData.configuredUniverses = v[1]
            }
            if (c == 'universe_status')
            {
                appData.universes[v[1]].status = v[2]
                appData.universes[v[1]].ok = v[3]
                appData.universes[v[1]].telemetry = v[4]
            }

            if(c=="varchange")
            {
                appData.scenemeta[v[1]]['vars'][v[2]]=v[3]
            }
            if (c == "delcue")
            {
                c = appData.cuemeta[v[1]]
                Vue.delete(appData.cuemeta, v[1]);
                Vue.delete(appData.cuevals, v[1]);
                Vue.delete(appData.scenecues[c.scene], c.name);
                appData.recomputeformattedCues();
            }

            if (c == "cnames")
            {
                Vue.set(appData.channelNames, v[1], v[2])
            }
            if (c == "universes")
            {
                appData.universes = v[1]
            }
            if (c == "soundoutputs")
            {
                appData.soundCards = v[1]
            }

            if(c=='soundsearchresults')
            {
                if(appData.soundsearch==v[1])
                {
                    appData.soundsearchresults = v[2]
                }
            }
            if (c == 'scenecues')
            {
                //Scenecues only gives us cue number and id info.
                //So if the data isn't in cuemeta, fill in what we can
                d = v[2]
                for (i in v[2])
                {
                    if (appData.cuemeta[d[i][0]] == undefined)
                    {
                        Vue.set(appData.cuemeta, d[i][0],
                        {
                            'name': i,
                            'number': d[
                                i][1]
                        })
                    }
                    
                    //Make the empty list
                    if (appData.scenecues[v[1]] == undefined)
                    {
                        Vue.set(appData.scenecues, v[1], {});
                    };


                    Vue.set(appData.scenecues[v[1]], i, d[i][0])
                }
                appData.recomputeformattedCues();
            }
            if (c == "cuedata")
            {
                d = {}
                Vue.set(appData.cuevals, v[1], d)

                for (i in v[2])
                {

                    if (!(i in appData.channelNames))
                    {
                        api_link.send(['getcnames', i])
                    }
                    Vue.set(appData.cuevals[v[1]], i, {})

                    for (j in v[2][i])
                    {
                        y = {
                            "u": i,
                            'ch': j,
                            "v": v[2][i][j]
                        }
                        Vue.set(appData.cuevals[v[1]][i], j, y)
                        //The other 2 don't need to be reactive, v does
                        Vue.set(y, 'v', v[2][i][j])

                    }
                }
                appData.refreshcuedata()

            }

            else if(c=="commands")
            {
                appData.availableCommands=v[1]
            }

            if (c == "scv")
            {
                x = []

                cue = v[1]
                universe = v[2]
                channel = v[3]
                value= v[4]
                
                if(appData.lockedFaders[cue+":"+universe+":"+channel]==true)
                {
                    return;
                }
            

                var needRefresh = false;
                //Empty universe dict
                if (!appData.cuevals[cue][universe])
                {

                    Vue.set(appData.cuevals[cue], universe, {})
                    needRefresh=1;
                }

                if (v[4] !== null)
                {

                    y = {
                        "u": universe,
                        'ch': channel,
                        "v": value
                    }
                    Vue.set(y,'v', value)
                    Vue.set(appData.cuevals[cue][universe], channel, y)
                }
                else
                {
                    Vue.delete(appData.cuevals[cue][universe], channel)
                    needRefresh=1;
                }
                if (needRefresh)
                {
                    appData.refreshcuedata()
                }

            }


            if (c == "go")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', true)

            }
            if (c == "stop")
            {

                Vue.set(appData.scenemeta[v[1]], 'active', false)

            }
            if (c == "ferrs")
            {

                appData.ferrs = v[1]

            }
            if (c == "fixtures")
            {

                appData.fixtures = v[1]

            }
            if (c == "fixtureclasses")
            {

                appData.fixtureClasses = v[1]
            }
            if (c == "fixtureclass")
            {

                Vue.set(appData.fixtureClasses, v[1], v[2])
            }
            if (c == "fixtureascode")
            {

                appData.fixturescode = v[1]
            }

            if (c == "fixtureAssignments")
            {

                appData.fixtureAssignments = v[1]
            }
            
            if (c == "del")
            {
                Vue.delete(appData.selectedCues, v[1])
                Vue.delete(appData.scenemeta, v[1])
                Vue.delete(appData.running_scenes, v[1])
                Vue.delete(appData.mtimes, v[1])
                appData.editingScene= null

            }

            if (c == "newscene")
            {
                appData.allScenes.push([v[1], v[2]])
            }
            if (c == 'soundfolderlisting')
            {
                if (v[1] == appData.soundfilesdir)
                {
                    appData.soundfileslisting = v[2]
                }
            }
        }



        api_link.upd = f
        api_link.send(['gasd']);
        api_link.send(['getCommands']);
            </script>

            <script>
                setInterval(function()
        {
            appData.unixtime = api_link.now() / 1000
        }, 1000 / 8)
        var shortcut = function(sc)
        {
            return function()
            {
                api_link.send(['shortcut', sc]);

            }
        }
        var next = function(sc)
        {
            return function()
            {
                api_link.send(['nextcuebyname', sc]);

            }
        }
        var goto = function(sc, cue)
        {
            return function()
            {
                api_link.send(['jumpbyname', sc, cue]);

            }
        }


        keysdown = {}
        keyHandle = function(e)
        {
            if(keysdown[e.key]!=undefined)
            {
                if(keysdown[e.key])
                {
                    return;
                }
                
            }
            keysdown[e.key]=true;
            e.preventRepeat();
            api_link.send(['event', "keydown."+e.key, 1, 'int',"__global__"])
        }
      keyUpHandle = function(e)
        {
             if(keysdown[e.key]!=undefined)
            {
                if(!keysdown[e.key])
                {
                    return;
                }
                
            }
            keysdown[e.key]=false;
            api_link.send(['event', "keyup."+e.key, 1, 'int',"__global__"])
        }
        rebind = function(data)
        {
            keyboardJS.reset()
            keyboardJS.bind(keyHandle)
            keyboardJS.bind(null,keyUpHandle)

        }
            </script>
