<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Terminal - Kaithem</title>

    <!-- xterm.js CSS -->
    <link rel="stylesheet" href="/static/css/xterm/xterm.css" />
    <link rel="stylesheet" href="/static/css/barrel.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background-color: #1e1e1e;
        overflow: hidden;
      }

      #terminal-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 10px;
      }

      #terminal {
        width: 100%;
        height: 100%;
      }

      .error-banner {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background-color: #d32f2f;
        color: white;
        padding: 15px;
        text-align: center;
        z-index: 1000;
        display: none;
      }

      .error-banner.show {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="error-banner" id="error-banner"></div>
    <div id="terminal-container">
      <div id="terminal"></div>
    </div>

    <!-- xterm.js core library (UMD) -->
    <script src="/static/js/thirdparty/xterm/xterm.js"></script>

    <!-- xterm.js addons (UMD) -->
    <script src="/static/js/thirdparty/xterm/addon-fit.js"></script>
    <script src="/static/js/thirdparty/xterm/addon-web-links.js"></script>

    <script type="module">
      // Get WebSocket URL from template variable
      import {
        ImageAddon
      } from "/static/js/thirdparty/xterm/addon-image.mjs";

      const wsUrl = "{{ ws_url }}";

      // Convert to WebSocket URL (handle both ws:// and wss://)
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const wsFullUrl = `${protocol}//${window.location.host}${wsUrl}`;

      // Initialize xterm.js (Terminal is available globally from UMD)
      const term = new Terminal({
        cursorBlink: true,
        fontSize: 14,
        fontFamily: '"Cascadia Code", "Fira Code", "Courier New", monospace',
        theme: {
          background: "#1e1e1e",
          foreground: "#d4d4d4",
          cursor: "#ffffff",
          cursorAccent: "#000000",
          selectionBackground: "#264f78",
          black: "#000000",
          red: "#cd3131",
          green: "#0dbc79",
          yellow: "#e5e510",
          blue: "#2472c8",
          magenta: "#bc3fbc",
          cyan: "#11a8cd",
          white: "#e5e5e5",
          brightBlack: "#666666",
          brightRed: "#f14c4c",
          brightGreen: "#23d18b",
          brightYellow: "#f5f543",
          brightBlue: "#3b8eea",
          brightMagenta: "#d670d6",
          brightCyan: "#29b8db",
          brightWhite: "#ffffff",
        },
        allowProposedApi: true,
      });

      // Load addons (addon classes are available globally from UMD)
      const fitAddon = new FitAddon.FitAddon();
      const webLinksAddon = new WebLinksAddon.WebLinksAddon();

      term.loadAddon(fitAddon);
      term.loadAddon(webLinksAddon);

      // customize as needed (showing addon defaults)
      const customSettings = {
        enableSizeReports: true, // whether to enable CSI t reports (see below)
        pixelLimit: 16777216, // max. pixel size of a single image
        sixelSupport: true, // enable sixel support
        sixelScrolling: true, // whether to scroll on image output
        sixelPaletteLimit: 256, // initial sixel palette size
        sixelSizeLimit: 25000000, // size limit of a single sixel sequence
        storageLimit: 128, // FIFO storage limit in MB
        showPlaceholder: true, // whether to show a placeholder for evicted images
        iipSupport: true, // enable iTerm IIP support
        iipSizeLimit: 20000000, // size limit of a single IIP sequence
      };

      const imageAddon = new ImageAddon(customSettings);
      term.loadAddon(imageAddon);
      // Open terminal in the DOM
      term.open(document.getElementById("terminal"));

      // Fit terminal to window
      fitAddon.fit();

      // Connect to WebSocket
      let ws;
      let reconnectAttempts = 0;
      const maxReconnectAttempts = 5;

      function showError(message) {
        const banner = document.getElementById("error-banner");
        banner.textContent = message;
        banner.classList.add("show");
        setTimeout(() => {
          banner.classList.remove("show");
        }, 5000);
      }

      function connect() {
        ws = new WebSocket(wsFullUrl);

        ws.onopen = () => {
          console.log("WebSocket connected");
          reconnectAttempts = 0;

          // Send initial terminal size
          ws.send(`resize:${term.cols}:${term.rows}`);
        };

        ws.onmessage = (event) => {
          if (event.data instanceof Blob) {
            // Handle binary data
            event.data.arrayBuffer().then((buffer) => {
              term.write(new Uint8Array(buffer));
            });
          } else {
            // Handle text data
            term.write(event.data);
          }
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          showError("WebSocket connection error");
        };

        ws.onclose = () => {
          console.log("WebSocket closed");

          if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            showError(
              `Connection lost. Reconnecting... (Attempt ${reconnectAttempts}/${maxReconnectAttempts})`
            );
            setTimeout(connect, 2000);
          } else {
            showError("Connection lost. Please refresh the page.");
            term.write("\r\n\x1b[1;31mConnection to server lost.\x1b[0m\r\n");
          }
        };
      }

      // Handle terminal input
      term.onData((data) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(data);
        }
      });

      // Handle terminal resize
      term.onResize(({ cols, rows }) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(`resize:${cols}:${rows}`);
        }
      });

      // Handle window resize
      window.addEventListener("resize", () => {
        fitAddon.fit();
      });

      // Handle page visibility changes
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) {
          fitAddon.fit();
        }
      });

      // Clean up on page unload
      window.addEventListener("beforeunload", () => {
        if (ws) {
          ws.close();
        }
      });

      // Start connection
      connect();

      // Focus terminal
      term.focus();
    </script>
  </body>
</html>
