<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <title>Projection Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .source-iframe {
            position: absolute;
            border: none;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <script type="module">
        import { VFX } from
            '/projection-mapper/static/vfx-js/vfx.esm.js';

        const MODULE = '{{ module }}';
        const RESOURCE = '{{ resource }}';
        const DATA = {{ data | safe }};

        let animationFrameId = null;
        const sourceElements = {};
        let vfxInstances = {};

        function initSources() {
            const container = document.getElementById(
                'canvas-container'
            );
            container.innerHTML = '';
            sourceElements = {};
            vfxInstances = {};

            DATA.sources.forEach((source) => {
                if (!source.visible) return;

                if (source.type === 'iframe') {
                    const iframe = document.createElement(
                        'iframe'
                    );
                    iframe.id = `source-${source.id}`;
                    iframe.src = source.config.url;
                    iframe.className = 'source-iframe';
                    iframe.sandbox.add(
                        'allow-scripts',
                        'allow-same-origin'
                    );

                    applyTransform(iframe, source);
                    container.appendChild(iframe);
                    sourceElements[source.id] = iframe;
                }
            });
        }

        function applyTransform(element, source) {
            const transform = source.transform || {};
            const corners = transform.corners;

            if (!corners) {
                // Default: full screen
                element.style.position = 'absolute';
                element.style.top = '0';
                element.style.left = '0';
                element.style.width = '100%';
                element.style.height = '100%';
            } else {
                element.style.position = 'absolute';
                element.style.width = '100%';
                element.style.height = '100%';

                const matrix = calculatePerspectiveMatrix(
                    corners
                );
                element.style.transformOrigin = '0 0';
                element.style.transform =
                    `matrix3d(${matrix.join(',')})`;
            }

            if (transform.opacity !== undefined) {
                element.style.opacity =
                    transform.opacity.toString();
            }

            if (transform.blend_mode) {
                element.style.mixBlendMode =
                    transform.blend_mode;
            }

            if (transform.rotation) {
                const current = element.style.transform || '';
                element.style.transform =
                    current +
                    ` rotate(${transform.rotation}deg)`;
            }
        }

        function calculatePerspectiveMatrix(corners) {
            const w = DATA.size?.width || 1920;
            const h = DATA.size?.height || 1080;

            const srcCorners = [
                [0, 0],
                [w, 0],
                [0, h],
                [w, h],
            ];

            const dstCorners = [
                [corners.tl.x, corners.tl.y],
                [corners.tr.x, corners.tr.y],
                [corners.bl.x, corners.bl.y],
                [corners.br.x, corners.br.y],
            ];

            return computeHomography(
                srcCorners,
                dstCorners
            );
        }

        function computeHomography(src, dst) {
            const A = [];

            for (let i = 0; i < 4; i++) {
                const x = src[i][0];
                const y = src[i][1];
                const xp = dst[i][0];
                const yp = dst[i][1];

                A.push([
                    x, y, 1, 0, 0, 0,
                    -xp * x, -xp * y, -xp,
                ]);
                A.push([
                    0, 0, 0, x, y, 1,
                    -yp * x, -yp * y, -yp,
                ]);
            }

            const h = solveHomography(A);
            return homographyToMatrix3d(h);
        }

        function solveHomography(A) {
            const n = 9;
            let x = [];
            for (let i = 0; i < n; i++) {
                x[i] = Math.random();
            }

            for (let iter = 0; iter < 10; iter++) {
                let Ax = [];
                for (let i = 0; i < A.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        sum += A[i][j] * x[j];
                    }
                    Ax.push(sum);
                }

                let ATAx = [];
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let k = 0; k < A.length; k++) {
                        sum += A[k][i] * Ax[k];
                    }
                    ATAx[i] = sum;
                }

                let norm = 0;
                for (let i = 0; i < n; i++) {
                    norm += ATAx[i] * ATAx[i];
                }
                norm = Math.sqrt(norm);

                if (norm > 1e-10) {
                    for (let i = 0; i < n; i++) {
                        x[i] = ATAx[i] / norm;
                    }
                }
            }

            return x;
        }

        function homographyToMatrix3d(h) {
            const H = [
                [h[0], h[1], h[2]],
                [h[3], h[4], h[5]],
                [h[6], h[7], h[8]],
            ];

            if (Math.abs(H[2][2]) > 1e-10) {
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        H[i][j] /= H[2][2];
                    }
                }
            }

            const matrix = [
                H[0][0], H[1][0], 0, H[2][0],
                H[0][1], H[1][1], 0, H[2][1],
                0, 0, 1, 0,
                H[0][2], H[1][2], 0, H[2][2],
            ];

            return matrix;
        }

        async function updateOnMessage(message) {
            if (message.type === 'transform_update') {
                const sourceId = message.source_id;
                const source = DATA.sources.find(
                    (s) => s.id === sourceId
                );
                if (source && sourceElements[sourceId]) {
                    source.transform.corners =
                        message.corners;
                    applyTransform(
                        sourceElements[sourceId],
                        source
                    );
                }
            } else if (message.type === 'reload') {
                // Reload from server
                const response = await fetch(
                    `/projection-mapper/api/data/${MODULE}/${RESOURCE}`
                );
                const newData = await response.json();
                Object.assign(DATA, newData);
                initSources();
            }
        }

        function connectWebSocket() {
            // Use secure WebSocket if HTTPS
            const protocol = window.location.protocol ===
                'https:' ? 'wss' : 'ws';
            const ws = new WebSocket(
                `${protocol}://${window.location.host}` +
                `/projection-mapper/ws/${MODULE}/${RESOURCE}`
            );

            ws.onopen = () => {
                console.log(
                    'WebSocket connected for viewer'
                );
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                updateOnMessage(message);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                // Reconnect after delay
                setTimeout(connectWebSocket, 3000);
            };
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initSources();
            connectWebSocket();
        });

        window.addEventListener('resize', () => {
            // Reapply transforms on window resize
            DATA.sources.forEach((source) => {
                if (sourceElements[source.id]) {
                    applyTransform(
                        sourceElements[source.id],
                        source
                    );
                }
            });
        });
    </script>
</body>
</html>
