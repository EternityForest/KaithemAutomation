<style type="text/css">
h2 {
	background-color: rgba(200, 255, 220, 0.4);
}

h3 {
	margin-top: 1em !important;
	margin-bottom: 1em !important;
	background-color: rgba(255, 255, 255, 0.3);
}

h4 {
	margin-top: 0.5em !important;
	margin-bottom: 0.5em !important;
	background-color: rgba(220, 220, 220, 0.25);
}
</style>
<%include file="/pageheader.html"/>
<title>Kaithem Help</title>
<h1>Virtual Resources</h1>

<div class="sectionbox">
    <h2>
        <a id="intro" name="intro"></a>Introduction
    </h2>

    <p>A Virtual Resource is an object that can exist in a module along with events, pages, etc, but is created at runtime through code and is never
        saved to disk. VirtualResources all descend from the class kaithem.resource.VirtualResource</p>

    <p>Virtual resources support a few handy features.
        They have an __html_repr__ method which returns a short piece of HTML to show in the module listing, and they support the concept of replacements and handoffs
        for seamless code updates.</p>



    <p>Every VirtualResource has a .name attribute which is either None, or is set the first time the resource is inserted. You do this by saying
        module['foo']  = vr from within any page or event. The name will become a tuple of (module, resource).</p>

    <p>If you try to overwrite an existing physical resource in this way, a RuntimeError results. If you try to overwrite another virtual resource,
        it will succeed, but only if the new one is of the same class or a subclass of the original.</p>

    <p>VirtualResources dissapear as soon as there are no references to them.</p>

    <p>Every VirtualResource also has an interface() method, which for the most part returns a fully transparent proxy to the VirtualResource</p>

    <p>However, when a VirtualResource is overwritten in a module namespace, any interfaces pointing to the old resource get updated to point to the new one. To best take advantage of this,
    avoid passing direct refernences to a VirtualResource, and pass around the interfaces, or directly look them up.</p>

    <p>Once an object has been replaced, it should no longer be used, but must proxy any important calls,
         and calls that would affect the mutable state of the object through to the new one.</p>

    <p> Objects are replaced using the old_one.handoff(new_one) method, which also sets old_one.replacement, 
        which is normally None, to the new one. If the object has already been replaced, it passes through the call
        to the replacement.</p>
    
    <p>Should you extend handoff(), you must do this same check, as in
<pre>x = self.replacement
if x and (not x is other):
    return x.handoff(self)</pre></p>


    <p>By subclassing VirtualResource and extending handoff(), you can create objects that allow seamless code modification at runtime without
        noticable interruptions. However, there may still be sneaky transient references to the old one around. One example is if the replacement
        happens just after a method call to the old one, before it has a chance to complete. Another example is if you have a reference to a property of
    the old object, as the proxying is not recursive.</p>

    <p>Another issue that can occur with VirtualResources is that if other code can add things to them, such as callbacks,
        those will all dissapear when the object gets replaced unless you copy them over in your handoff()</p>

    <p>In general, mutable runtime data should be copied over(Including open sockets, game score data, lighting values, etc),
        wheras mostly-static configuration and code should not be.</p>

    <p>Be sure to clearly document what does and does not get transferred.</p>

    <p>Aside from handoff, replacement, name, and interface, VirtualResource does not define any public names and doesn't do
        much when instantiated, so you can use them just like any other object for the most part.</p>
</div>
<%include file="/pagefooter.html"/>
